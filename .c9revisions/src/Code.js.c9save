{"ts":1357250216598,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n *\n * Code.js\n * \n * Class / Object Descripion Engine for Javascript\n * \n * https://github.com/neuromantic/CodeJS\n *\n * Copyright 2012, Neuromantic Industries\n * Licensed under the MIT license.\n *\n */\n\n( function ( ) {\n\tglobal = ( typeof window == 'object') ? window : ( typeof global == 'object') ? global : { dev: null }; \n\tconsole = console || {};\n\tconsole.log = console.log || function () {};\n\tif ( typeof require == 'function' ) {\n\t\tfs = require( 'fs' );\n\t\tpath = require('path');\n\t\tast = require('uglify-js').parser;\n\t\tugg = require('uglify-js').uglify;\n\t\thttp = require( 'http' );\n\t}\n\tvar _ = {\n\t\tdebugging : true,\n\t\tapplication : {},\n\t\tutil : {\n\t\t\tstringify: function ( obj, done ){\n\t\t\t\tif ( typeof obj === 'undefined' ){\n\t\t\t\t\treturn '{undefined}';\n\t\t\t\t}\n\t\t\t\tif ( obj === null){\n\t\t\t\t\treturn '{null}';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( obj.tagName){\n\t\t\t\t\treturn '<' + obj.tagName + '/>';\n\t\t\t\t}\n\t\t\t\tif (obj._className){\n\t\t\t\t\treturn obj.toString();\n\t\t\t\t}\n\t\t\t\tswitch( typeof obj){\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tvar s = '{ ';\n\t\t\t\t\t\tfor (var key in obj ){\n\t\t\t\t\t\t\tvar val = obj[key];\n\t\t\t\t\t\t\tvar type = typeof val;\n\t\t\t\t\t\t\tif(done){\n\t\t\t\t\t\t\t\tval = ( type === 'array' || type === 'object' || type === 'function' ) ? type : val;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tval = type === 'string' ?  '\"' + obj +'\"' : _.util.stringify(val, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts+= ' ' + key + ' : ' + val + ',' ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\t\ts+=' }';\n\t\t\t\t\t\treturn s\n\t\t\t\t\tcase 'function':\n\t\t\t\t\t\treturn '[function]';\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\tvar s = '[ ';\n\t\t\t\t\t\tfor (var i = 0; i < obj.length; i++ ){\n\t\t\t\t\t\t\tvar val = obj[i];\n\t\t\t\t\t\t\tval = _.util.stringify(val, true);\n\t\t\t\t\t\t\ts+= ' ' + key + ' : ' + val + ',' ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\t\ts+=' ]';\n\t\t\t\t\t\treturn s\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeepCopy : deepCopy,\n\t\t\tscope : function ( fn, scope, functionName ) {\n\t\t\t\treturn function () {\n\t\t\t\t\tvar s = '';\n\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\ts+=arguments[i]+\",\"\n\t\t\t\t\t}\n\t\t\t\t\ts = s.substring(0,-1)\n// _debug( scope + '.' + functionName+'(' + s + ')' );\n\t\t\t\t\t return fn.apply( scope, arguments );\n\t\t\t\t}//closure\n\t\t\t},//scope\n\t\t\tisMethod : function( property ) {\n\t\t\t\treturn ( ( typeof property == 'function' ) && ( ! ( property instanceof RegExp ) ) );\n\t\t\t}//isMethod\n\t\t},// util\n\t\tloader : {\n\t\t\tqueue : [],\n\t\t\t_import : function( classPath, immediately ) {//--------------------------------------------------------------- loader._import (load)\n\t\t\t\tif( _.loader.queue.indexOf( classPath ) < 0 ) {\n\t\t\t\t\t_.loader.load( classPath );// push path into loading queue\n\t\t\t\t}// if\n\t\t\t},// _import\n\t\t\t_class : function ( className ) {//--------------------------------------------------------------- loader._class (stub)\n//_debug( 'creating stub class for', className );\n\t\t\t\tvar stub = { \n\t\t\t\t\t_extends : function( superName ) {\n\t\t\t\t\t\tthis._super = superName;//set super name for definition tree\n\t\t\t\t\t}// _extends\n\t\t\t\t};// stub\n\t\t\t\tglobal[ className ] = stub;\n\t\t\t\treturn global[ className ];\n\t\t\t},// _class\n\t\t\tload : function( classPath, first ) {\n\t\t\t\tvar code, scriptPath;\n//TODO: http classPaths\n\t\t\t\tvar binPath = 'bin/' + classPath;\n\t\t\t\tscriptPath = 'src/' + classPath.replace( /\\./g, '/' ) + '.js';\n\t\t\t\ttry{\n\t\t\t\t\tthis.queue.push( classPath);\n\t\t\t\t\tif( fs && path && ast && ugg ){//server\n\t\t\t\t\t\ttry{\n//_debug( 'looking for bytecode in', binPath );\n\t\t\t\t\t\t\tcode = fs.readFileSync( binPath );\n\t\t\t\t\t\t}catch( e ){\n//_debug( 'no bytecode available.');\n\t\t\t\t\t\t\ttry{\n//_debug( 'loading source code from', scriptPath );\n\t\t\t\t\t\t\t\tcode = fs.readFileSync( scriptPath, 'ascii' );\n\t\t\t\t\t\t\t\ttry{\n//_debug( 'generating bytecode for', classPath );\t\n\t\t\t\t\t\t\t\t\tif( ! _.debugging ){\n\t\t\t\t\t\t\t\t\t\tcode = ast.parse( code ); // parse code and get the initial AST\n\t\t\t\t\t\t\t\t\t\tif(classPath == 'Code'){\n\t\t\t\t\t\t\t\t\t\t\tcode = ugg.ast_mangle( code ); // get a new AST with mangled names\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcode = ugg.ast_squeeze( code ); // get an AST with compression optimizations\n\t\t\t\t\t\t\t\t\t\tcode = ugg.gen_code( code ); // compressed code here\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(! path.existsSync( 'bin/' ) ){\n\t\t\t\t\t\t\t\t\t\tfs.mkdirSync( 'bin/');\n\t\t\t\t\t\t\t\t\t}\n//_debug( 'writing bytecode to', binPath, code );\n\t\t\t\t\t\t\t\t\tfs.writeFileSync( binPath, code );\n\t\t\t\t\t\t\t\t}catch (error ){\n\t\t\t\t\t\t\t\t\tthrow new Error( error );\n_debug( 'error creating bytecode' );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}catch( error ){\n_debug( 'file system error');\n\t\t\t\t\t\t\t\tthrow new Error( error );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {//client // ( typeof XMLHttpRequest == \"function\" )\n//_debug( 'streaming source code from', scriptURL );\n\t\t\t\t\t\tvar scriptURL = scriptPath;\n\t\t\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\t\t\trequest.open( 'GET', scriptURL, false );\n\t\t\t\t\t\trequest.send( null );\n\t\t\t\t\t\tif ( request.status == 200 ) {\n\t\t\t\t\t\t\tcode = request.responseText;\n\t\t\t\t\t\t} else {// else if\n_debug( 'XMLHttpRequest error');\n\t\t\t\t\t\t    throw new Error( request.status );\n\t\t\t\t\t\t};// else\n\t\t\t\t\t}  \n\t\t\t\t}catch( error ){\n_debug( 'error loading', classPath, ':', error.message ) ;\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n//_debug( 'loaded', classPath, '. processing imports' );\n\t\t\t\ttry{\n\t\t\t\t\tglobal._import = this._import;//load\n\t\t\t\t\tglobal._class = this._class;//stub\n\t\t\t\t\tcode = code.toString();\n\t\t\t\t\tif(code.indexOf('_import') > -1 || code.indexOf('_class') > -1){\n\t\t\t\t\t\teval( code );\n\t\t\t\t\t}\n\t\t\t\t}catch( error ){\n_debug( 'error completing imports for '+  classPath + '. Error Text:' + error.message );\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\tvar className = classPath.split( '.' ).pop();\n\t\t\t\tglobal[ className ] = global[ className ] || {}\n\t\t\t\tglobal[ className ]._script = code;//store script\n\t\t\t\t_.compiler.queue.push(className );// add script to compilation queue\n\t\t\t\tif( this.queue.length == _.compiler.queue.length ){\n\t\t\t\t\t_.compiler.compileClasses();\n\t\t\t\t\tthis.queue = [];\n\t\t\t\t}// if\n\t\t\t}//, load\n\t\t},// loader\n\t\tcompiler : {\n\t\t\tbuffer :'',\n\t\t\tqueue : [],\n\t\t\t_import : function( classPath, immediately ) {\n\t\t\t\tvar className = classPath.split( '.' ).pop();\n\t\t\t\t_.compiler.compile( className );\n\t\t\t},// _import\n\t\t\t_class : function( className ) {\n\t\t\t\treturn {_extends:function (){}}\n\t\t\t},// _import\n\t\t\tcompileClasses : function () {\n//_debug( 'compiling classes' );\n\t\t\t\tvar className;\n\t\t\t\twhile ( className = this.queue[ 0 ] ) {\n\t\t\t\t\tthis.compile( className );\n\t\t\t\t}// while\n\t\t\t\t _.interpreter.defineClasses();\n\t\t\t\t this._queue = [];\n\t\t\t},// compileClasses\n\t\t\tcompile : function ( className ) {\n\t\t\t\tvar index = this.queue.indexOf( className );\n\t\t\t\tif ( index >= 0 ) {\n\t\t\t\t\tthis.queue.splice( index, 1 );\n\t\t\t\t\tvar classObject = global [ className ];\n//_debug( 'adding class', className );\n\t\t\t\t\tglobal._import = this._import;\n\t\t\t\t\tglobal._class = this._class;\n\t\t\t\t\tif( classObject._script.indexOf ('_class') > -1 || classObject._script.indexOf('_import') > -1 ){\n\t\t\t\t\t\teval( classObject._script );\n\t\t\t\t\t}\n\t\t\t\t\tthis.buffer = this.buffer.concat( classObject._script );\n//_debug( this.buffer.length, 'bytes', this.queue.length, 'scripts remain.' );\n\t\t\t\t}// if\n\t\t\t}//compile\n\t\t},// compiler\n\t\tinterpreter : {\n\t\t\tinitializing : false,\n\t\t\t_import : function( classPath, immediately ) {//--------------------------------------------------------------- interpreter._import (null)\n\t\t\t},// _import\n\t\t\t_class : function( className, properties ) {//--------------------------------------------------------------- interpreter._class define\n//_debug( '_class', className );\n\t\t\t\tif( global[ className ] &&  global[ className ]._constructor ) {// if class is stub\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tvar newClass = Class._plus( className, properties );// create the class from Class object\n\t\t\t\t\tnewClass._extends = function( parentClassName, properties ) {\n//_debug( '_extends', parentClassName );\n\t\t\t\t\t\t\tglobal[ className ] = global[ parentClassName ]._plus( className, properties );\n\t\t\t\t\t\t \tglobal[ className ]._className = className;\n\t\t\t\t\t}// _extends\n\t\t\t\t\tglobal[ className ] = newClass;\n\t\t\t\t} //if\n\t\t\t\t_.interpreter.applicationName = className;\n\t\t\t\treturn global[ className ]\n\t\t\t },// _class\n\t\t\tdefineClasses : function () {\n//_debug( 'defining classes' );\n\t\t\t\tglobal._import = this._import; // null\n\t\t\t\tglobal._class = this._class; // define / extend class\n\t\t\t\teval( _.compiler.buffer );\n\t\t\t\t_.compiler.buffer = '';\n\t\t\t\tCode.x();\n\t\t\t}//defineClasses\n\t\t}// interpreter\n\t};// _\n\t\n\t_trace = function () {\n\t\tvar output = \"\";\n\t\tvar args = arguments;\n\t\tfor( index in args ) {\n\t\t\tvar token = _.util.stringify(args[ index ]);\n\t\t\toutput += token + ( ' ' );\n\t\t};// for\n\t\tconsole.log( output );\n\t};// _trace\n\t\n\t_debug = function () {\n\t\tif( _.debugging ) _trace.apply( this, arguments );\n\t};//\n\t\n\t_package = function() { // Future Use\n// _trace( 'package', arguments[ 0 ] );\n\t};// _package\n\t\n\t\n\t// DON'T GET CUTE.\n\t\t\n\t/* \n\t * \n\t * Class is a modification of 'Class' \n\t * originally by the immortal John Resig\n\t * \n\t * http://bit.ly/4U5H\n\t *\t\n\t */\t\n//\t   var fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n\t  // The base Class implementation -- \n\t  // provides _get and _set shortcuts to eliminate abiguous assignment ( is it a  property or a getSetter ? )\n\t  // provides .add() to replace += \n\t  var Class = function(){};\n\t  Class._className = 'Class';\n\t  Class.prototype = {\n\t\t\t_get : function( propertyName ){\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t};\n\t\t\t\treturn ( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]() : this[ propertyName ];\n\t\t\t},\n\t\t\t_set : function( propertyName, value ){\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\tthis[propertyName] = value;\n\t\t\t\t}else{\n\t\t\t\t\t( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]( value ) : this[ propertyName ] = value;\n\t\t\t\t};\n\t\t\t\n\t\t\t},\n\t\t\t_add : function( value, propertyName ){\n\t\t\t\tvalue = value || 1;\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\tthis[propertyName] = value;\n\t\t\t\t}else{\n\t\t\t\t\t( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]( this[ propertyName ]() + value ) : this[ propertyName ] += value;\n\t\t\t\t};\n\t\t\t},\n\t\t\ttoString : function () { return '['+this._className+']'; } \n\t\t};\n\t\t\n\t  // Create a new Class that inherits from this class\n\tClass._plus = function(className, additions) {\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the __init__ constructor)\n\t\t_.interpreter.initializing = true;\n\t\tvar newPrototype = new this();\n\t\t_.interpreter.initializing = false;\n\t\tnewPrototype._className = className;\n\t\tvar superPrototype =  this.prototype;\n\n\t\tnewPrototype._ = superPrototype._ ? _.util.deepCopy( superPrototype._ ) : {}; // private space\n\t\tnewPrototype.__ = superPrototype.__ ? _.util.deepCopy( superPrototype.__ ) : { getters : {}, setters: {}, getSetterNames:[] }; // getters/setters space\n\t\t\n\t\t// TODO: getter/setters proper\n\n\t\tfor (var name in additions) {\n\t\t\tvar addition = additions[ name ];\n\t\t\tvar\tpropertyKeyword;\n\t\t\tvar\tpropertyType;\n\t\t\tvar propertyName = name;\n\t\t\tvar propertyDefault = '[function]';\n\t\t\tvar attachTarget = {};\n\t\t\t\n\t\t// TODO: getter/setters proper ?\n\t\t\n\t\t\tif ( name.indexOf( 'private_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'private';\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tattachTarget = newPrototype._;\n\t\t\t} else if ( name.indexOf( 'static_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'static';\n\t\t\t\tattachTarget = ClassObject;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t}  else if ( name.indexOf( 'get_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'get';\n\t\t\t\tattachTarget = newPrototype.__.getters;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tif( newPrototype.__.getSetterNames.indexOf( propertyName ) == -1 ){\n\t\t\t\t\tnewPrototype.__.getSetterNames.push( propertyName );\n\t\t\t\t}\n\t\t\t}  else if ( name.indexOf( 'set_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'set';\n\t\t\t\tattachTarget = newPrototype.__.setters;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tif( newPrototype.__.getSetterNames.indexOf( propertyName ) == -1 ){\n\t\t\t\t\tnewPrototype.__.getSetterNames.push( propertyName );\n\t\t\t\t}\n\t\t\t} else if ( name === className ){\n\t\t\t\tpropertyKeyword = 'constructor';\n\t\t\t\tattachTarget = newPrototype;\n\t\t\t\tpropertyName = '__init__'\n\t\t\t} else {\n\t\t\t\tpropertyKeyword = 'public';\n\t\t\t\tattachTarget = newPrototype;\n\t\t\t};\n\n\t\t\tvar property;\n\t\t\tif ( typeof addition == 'function'  ) {\n\t\t      \tpropertyType = 'function';\n\t\t      \tproperty = ( function( propertyName, fn, _super ){\n\t\t\t        return function() {\n\t\t\t            var tmp = this._super;\n\t\t\t            // Allow this._super() to call superconstructor, and allow this._super().*() to call the super method\n\t\t\t\t        this._super = function(){\n\t\t\t            \tif( propertyName === '__init__' ) {\n\t\t\t\t\t\t\t\tvar __init__ = _super.__init__ || function(){};\n\t\t\t\t\t\t\t\t_super = _super._superPrototype;\n\t\t            \t\t\treturn __init__.apply( this, arguments)\n\t\t\t\t            }else{\n\t\t\t\t            \tvar names = [];\n\t\t\t\t            \tvar sup = {};\n\t\t\t\t            \tfor( var memberName in _super ){\n\t\t\t\t            \t\tvar member = _super[ memberName ]\n\t\t\t\t            \t\tif( typeof member === 'function' ){\n\t\t\t\t            \t\t\tsup[ memberName ] = _.util.scope( member, this, memberName );\n\t\t\t\t\t            \t\tnames.push(memberName)\n\t\t\t\t            \t\t}\n\t\t\t\t            \t}\n\t\t\t\t            \t_super = _super._superPrototype;\n\t\t\t\t            \treturn sup\n\t\t\t\t            }\n\t\t\t            }\n\t\t\t            // The __init__ method only need to be bound temporarily, so we\n\t\t\t            // remove it when we're done executing\n\t\t\t            var ret = fn.apply( this, arguments );        \n\t\t\t            this._super = tmp;\n\t\t\t            _super = superPrototype;\n\t\t\t            return ret;\n\t\t\t\t    };\n\t\t        })( propertyName, addition, superPrototype );\n\t\t\t}else{\n\t\t\t\tpropertyType = 'var';\n\t\t\t\tpropertyDefault = addition;\n\t\t    \tproperty = _.util.deepCopy( addition );\n\t\t    }\n\t\t\tattachTarget[ propertyName ] = property;\n_debug('\\t', propertyKeyword, propertyType, propertyName, '=', propertyDefault );\n\t\t}\n\t\t\n\t\t// Create getter / setter properties\n\t\tfor ( var index in newPrototype.__.getSetterNames ){\n\t\t\tvar getSetterName = newPrototype.__.getSetterNames[ index ];\n//_debug( 'property name:', getSetterName);\t\t\t\n\t\t\tvar getter = newPrototype.__.getters[getSetterName ];\n//_debug( 'getter function:', getter) ;\t\t\n\t\t\tvar setter = newPrototype.__.setters[getSetterName ];\n//_debug( 'setter function:', setter );\t\t\n\t\t\tnewPrototype[ getSetterName ] = ( function( getter, setter, getSetterName ){\n\t\t\t\treturn function ( value ) {\n\t\t\t\t\tif( value === undefined ) {\n\t\t\t\t\t\tif( getter ) {\n//_debug( 'getting', getSetterName, 'of', this, ':', getter());\n\t\t\t\t\t\t\treturn getter.call( this );\n\t\t\t\t\t\t}else return;\n\t\t\t\t\t}\n\t\t\t\t\tif( setter ){\n// _debug( 'setting', getSetterName, 'of', this, 'to', value);\n\t\t\t\t\t\tsetter.call( this, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})( getter, setter, getSetterName );\n\t\t};\n\t\t// The dummy class constructor (scoping)\n\t\tfunction ClassObject() {\n\t\t  // All construction is actually done in the __init__ method (declared using the new Class name as string ( _className ) )\n\t\t\tthis._ = _.util.deepCopy( this._ );\n\t\t\tthis.__ = _.util.deepCopy( this.__ );\n\t\t\tif ( !_.interpreter.initializing ){\n_debug( 'new', this._className );\n\t\t\t\tif ( this._className.indexOf( 'Event' ) < 0 && [ 'Dictionary' ].indexOf( this._className ) < 0 ) {\n\n\t\t\t\t};\n\t\t\t\tfor ( var propertyName in this ){\n\t\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\t\tif ( _.util.isMethod( property ) && [ 'toString', '_get', '_set', '_add' ].indexOf( propertyName) < 0 ){\n//_debug( 'scoping public', propertyName )\n\t\t\t\t\t\tthis[ propertyName ] = _.util.scope( property, this, propertyName );\n\t\t\t\t\t};//if\n\t\t\t\t};//for\n\t\t\t\t\n\t\t\t\tfor ( propertyName in this._ ){\n\t\t\t\t\tvar property = this._[ propertyName ];\n\t\t\t\t\tif ( _.util.isMethod( property ) ){\n//_debug( 'scoping private', propertyName )\n\t\t\t\t\t\tthis._[ propertyName ] = _.util.scope( property, this );\n\t\t\t\t\t}//if\n\t\t\t\t}//for\n\t\t\t  \tif( this.__init__ ) {\n\t\t\t \t\tthis.__init__.apply( this, arguments );\n\t\t\t  \t};//if\n\t\t\t}//if\n\t\t}\n\t\t//inheritance chain\n\t\tnewPrototype._superPrototype =  superPrototype;\n\t\t// Populate our constructed prototype object\n\t\tClassObject.prototype = newPrototype;\n\t\t\n\t\t// Enforce the constructor to be what we expect\n\t\tClassObject.constructor = ClassObject;\n\t\t\n\t\t// And make this class extensible\n\t\tClassObject._plus = arguments.callee;\n\t\t\n\t\treturn ClassObject;\n\t};\n\t\t\t\n\tvar Code = function(){\n\t\treturn Code.c('Code');\n\t};\n\tCode.r = function ( applicationClassPath, parameters ) {\n_debug('Code.r(',applicationClassPath,',', _.util.stringify(parameters), ')');\n\t_.application.parameters = parameters;\n\t_.application.classPath = applicationClassPath;\n\t\tglobal._import = _.loader._import;\n\t\t_import( applicationClassPath );\n\t\t\t\t\n\t};\n\tCode.x = function ( applicationClassPath, parameters ){\n_debug('Code.x(',applicationClassPath,',', _.util.stringify(parameters), ')');\n\t\tparameters = parameters || this._.application.parameters;\n\t\tapplicationClassPath = applicationClassPath || this._.application.classPath;\n\t\tvar applicationClassName = applicationClassPath.split( '.' ).pop();\n\t\tnew global[ applicationClassName ](parameters);//no namespace\n\t\t_.application = {};\n\t};\n\tCode.c = function ( applicationClassPath ) {\n_debug('Code.c(',applicationClassPath,')');\n\t\tvar libPath = 'lib/'+applicationClassPath+'.js';\n\t\tvar buffer;\n\t\tif( fs ) {\n\t\t\ttry{\n\t\t\t\tbuffer = fs.readFileSync( libPath, 'ascii' );\n\t\t\t}catch( e ){\n\t\t\t\t_debug( 'no library at', libPath);\n\t\t\t}\n\t\t}\n\t\tif( ! buffer ){\n\t\t\tvar interpreter = _.interpreter;\n\t\t\t_.interpreter = {\n\t\t\t\tdefineClasses : function () {\n\t_debug( 'bypassing interpreter.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tglobal._import = _.loader._import;\n\t\t\t_import( applicationClassPath );\n\t\t\tbuffer = _.compiler.buffer;\n\t\t\tif( fs && path ){\n\t\t\t\t_debug (' fs & path');\n\t\t\t\tif(! path.existsSync( 'lib/' ) ){\n\t\t\t\t\t_debug( 'creating lib folder')\n\t\t\t\t\tfs.mkdirSync( 'lib/');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t_debug( 'saving lib file to', libPath)\n\t\t\t\tfs.writeFileSync( libPath,  buffer)\n\t\t\t}\n\t\t\t_.compiler.buffer = '';\n\t\t\t_.interpreter = interpreter;\t\n\t\t}\n\t\treturn buffer\n\t};\n\tCode._ = _;\n\tglobal.Code = Code;\t\n\tglobal._import = _.interpreter._import;\n\tglobal._class = _.interpreter._class;\n\t_debug('Code ready.')\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////// Goin' Deep /////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n//\t DEEP COPY props http://oranlooney.com/deep-copy-javascript/\n//\t   This section is part of OWL JavaScript Utilities.\n//\n//\tOWL JavaScript Utilities is free software: you can redistribute it and/or \n//\tmodify it under the terms of the GNU Lesser General Public License\n//\tas published by the Free Software Foundation, either version 3 of\n//\tthe License, or (at your option) any later version.\n//\t\n//\tOWL JavaScript Utilities is distributed in the hope that it will be useful,\n//\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n//\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//\tGNU Lesser General Public License for more details.\n//\t\n//\tTo receive a copy of the GNU Lesser General Public License, see: <http://www.gnu.org/licenses/>.\t\n\n//\t the re-usable constructor function used by clone().\n\tfunction Clone() {};\n\n//\t clone objects, skip other types.\n\tfunction clone(target) {\n\t\tif ( typeof target == 'object' ) {\n\t\t\tClone.prototype = target;\n\t\t\treturn new Clone();\n\t\t} else {\n\t\t\treturn target;\n\t\t}\n\t}\n\n\n//\t Shallow Copy \n\tfunction copy(target) {\n\t\tif (typeof target !== 'object' ) {\n\t\t\treturn target;  // non-object have value sematics, so target is already a copy.\n\t\t} else {\n\t\t\tvar value = target.valueOf();\n\t\t\tif (target != value) { \n//\t\t\t\t the object is a standard object wrapper for a native type, say String.\n//\t\t\t\t we can make a copy by instantiating a new object around the value.\n\t\t\t\treturn new target.constructor(value);\n\t\t\t} else {\n//\t\t\t\t ok, we have a normal object. If possible, we'll clone the original's prototype \n//\t\t\t\t (not the original) to get an empty object with the same prototype chain as\n//\t\t\t\t the original.  If just copy the instance properties.  Otherwise, we have to \n//\t\t\t\t copy the whole thing, property-by-property.\n\t\t\t\tif ( target instanceof target.constructor && target.constructor !== Object ) { \n\t\t\t\t\tvar c = clone(target.constructor.prototype);\n\t\t\t\t\n//\t\t\t\t\t give the copy all the instance properties of target.  It has the same\n//\t\t\t\t\t prototype as target, so inherited properties are already there.\n\t\t\t\t\tfor ( var property in target) { \n\t\t\t\t\t\tif (target.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tc[property] = target[property];\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar c = {};\n\t\t\t\t\tfor ( var property in target ) c[property] = target[property];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t}\n\n//\t Deep Copy\n\tvar deepCopiers = [];\n\n\tfunction DeepCopier(config) {\n\t\tfor ( var key in config ) this[key] = config[key];\n\t}\n\tDeepCopier.prototype = {\n\t\tconstructor: DeepCopier,\n\n//\t\t determines if this DeepCopier can handle the given object.\n\t\tcanCopy: function(source) { return false; },\n\n//\t\t starts the deep copying process by creating the copy object.  You\n//\t\t can initialize any properties you want, but you can't call recursively\n//\t\t into the DeeopCopyAlgorithm.\n\t\tcreate: function(source) { },\n\n//\t\t Completes the deep copy of the source object by populating any properties\n//\t\t that need to be recursively deep copied.  You can do this by using the\n//\t\t provided deepCopyAlgorithm instance's deepCopy() method.  This will handle\n//\t\t cyclic references for objects already deepCopied, including the source object\n//\t\t itself.  The \"result\" passed in is the object returned from create().\n\t\tpopulate: function(deepCopyAlgorithm, source, result) {}\n\t};\n\n\tfunction DeepCopyAlgorithm() {\n//\t\t copiedObjects keeps track of objects already copied by this\n//\t\t deepCopy operation, so we can correctly handle cyclic references.\n\t\tthis.copiedObjects = [];\n\t\tthisPass = this;\n\t\tthis.recursiveDeepCopy = function(source) {\n\t\t\treturn thisPass.deepCopy(source);\n\t\t}\n\t\tthis.depth = 0;\n\t}\n\tDeepCopyAlgorithm.prototype = {\n\t\tconstructor: DeepCopyAlgorithm,\n\n\t\tmaxDepth: 256,\n\t\t\t\n//\t\t add an object to the cache.  No attempt is made to filter duplicates;\n//\t\t we always check getCachedResult() before calling it.\n\t\tcacheResult: function(source, result) {\n\t\t\tthis.copiedObjects.push([source, result]);\n\t\t},\n\n//\t\t Returns the cached copy of a given object, or undefined if it's an\n//\t\t object we haven't seen before.\n\t\tgetCachedResult: function(source) {\n\t\t\tvar copiedObjects = this.copiedObjects;\n\t\t\tvar length = copiedObjects.length;\n\t\t\tfor ( var i=0; i<length; i++ ) {\n\t\t\t\tif ( copiedObjects[i][0] === source ) {\n\t\t\t\t\treturn copiedObjects[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\t\n//\t\t deepCopy handles the simple cases itself: non-objects and object's we've seen before.\n//\t\t For complex cases, it first identifies an appropriate DeepCopier, then calls\n//\t\t applyDeepCopier() to delegate the details of copying the object to that DeepCopier.\n\t\tdeepCopy: function(source) {\n//\t\t\t null is a special case: it's the only value of type 'object' without properties.\n\t\t\tif ( source === null ) return null;\n\n//\t\t\t All non-objects use value semantics and don't need explict copying.\n\t\t\tif ( typeof source !== 'object' ) return source;\n\n\t\t\tvar cachedResult = this.getCachedResult(source);\n\n//\t\t\t we've already seen this object during this deep copy operation\n//\t\t\t so can immediately return the result.  This preserves the cyclic\n//\t\t\t reference structure and protects us from infinite recursion.\n\t\t\tif ( cachedResult ) return cachedResult;\n\n//\t\t\t objects may need special handling depending on their class.  There is\n//\t\t\t a class of handlers call \"DeepCopiers\"  that know how to copy certain\n//\t\t\t objects.  There is also a final, generic deep copier that can handle any object.\n\t\t\tfor ( var i=0; i<deepCopiers.length; i++ ) {\n\t\t\t\tvar deepCopier = deepCopiers[i];\n\t\t\t\tif ( deepCopier.canCopy(source) ) {\n\t\t\t\t\treturn this.applyDeepCopier(deepCopier, source);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// the generic copier can handle anything, so we should never reach this line.\n\t\t\tthrow new Error(\"no DeepCopier is able to copy \" + source);\n\t\t},\n\n//\t\t once we've identified which DeepCopier to use, we need to call it in a very\n//\t\t particular order: create, cache, populate.  This is the key to detecting cycles.\n//\t\t We also keep track of recursion depth when calling the potentially recursive\n//\t\t populate(): this is a fail-fast to prevent an infinite loop from consuming all\n//\t\t available memory and crashing or slowing down the browser.\n\t\tapplyDeepCopier: function(deepCopier, source) {\n//\t\t\t Start by creating a stub object that represents the copy.\n\t\t\tvar result = deepCopier.create(source);\n\n//\t\t\t we now know the deep copy of source should always be result, so if we encounter\n//\t\t\t source again during this deep copy we can immediately use result instead of\n//\t\t\t descending into it recursively.  \n\t\t\tthis.cacheResult(source, result);\n\n//\t\t\t only DeepCopier::populate() can recursively deep copy.  So, to keep track\n//\t\t\t of recursion depth, we increment this shared counter before calling it,\n//\t\t\t and decrement it afterwards.\n\t\t\tthis.depth++;\n\t\t\tif ( this.depth > this.maxDepth ) {\n\t\t\t\tthrow new Error(\"Exceeded max recursion depth in deep copy.\");\n\t\t\t}\n\n//\t\t\t It's now safe to let the deepCopier recursively deep copy its properties.\n\t\t\tdeepCopier.populate(this.recursiveDeepCopy, source, result);\n\n\t\t\tthis.depth--;\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n//\t entry point for deep copy.\n//\t   source is the object to be deep copied.\n//\t   maxDepth is an optional recursion limit. Defaults to 256.\n\tfunction deepCopy(source, maxDepth) {\n\t\tvar deepCopyAlgorithm = new DeepCopyAlgorithm();\n\t\tif ( maxDepth ) deepCopyAlgorithm.maxDepth = maxDepth;\n\t\treturn deepCopyAlgorithm.deepCopy(source);\n\t}\n\n//\t publicly expose the DeepCopier class.\n\tdeepCopy.DeepCopier = DeepCopier;\n\n//\t publicly expose the list of deepCopiers.\n\tdeepCopy.deepCopiers = deepCopiers;\n\n//\t make deepCopy() extensible by allowing others to \n//\t register their own custom DeepCopiers.\n\tdeepCopy.register = function(deepCopier) {\n\t\tif ( !(deepCopier instanceof DeepCopier) ) {\n\t\t\tdeepCopier = new DeepCopier(deepCopier);\n\t\t}\n\t\tdeepCopiers.unshift(deepCopier);\n\t}\n\n//\t Generic Object copier\n//\t the ultimate fallback DeepCopier, which tries to handle the generic case.  This\n//\t should work for base Objects and many user-defined classes.\n\tdeepCopy.register({\n\t\tcanCopy: function(source) { return true; },\n\n\t\tcreate: function(source) {\n\t\t\tif ( source instanceof source.constructor ) {\n\t\t\t\treturn clone(source.constructor.prototype);\n\t\t\t} else {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var key in source ) {\n\t\t\t\tif ( source.hasOwnProperty(key) ) {\n\t\t\t\t\tresult[key] = deepCopy(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t});\n\n//\t Array copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) {\n\t\t\treturn ( source instanceof Array );\n\t\t},\n\n\t\tcreate: function(source) {\n\t\t\treturn new source.constructor();\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var i=0; i<source.length; i++) {\n\t\t\t\tresult.push( deepCopy(source[i]) );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t});\n\n//\t Date copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) {\n\t\t\treturn ( source instanceof Date );\n\t\t},\n\n\t\tcreate: function(source) {\n\t\t\treturn new Date(source);\n\t\t}\n\t});\n\n//\t HTML DOM Node\n\n//\t utility function to detect Nodes.  In particular, we're looking\n//\t for the cloneNode method.  The global document is also defined to\n//\t be a Node, but is a special case in many ways.\n\tfunction isNode(source) {\n\t\tif ( global.Node ) {\n\t\t\treturn source instanceof Node;\n\t\t} else {\n\t\t\t// the document is a special Node and doesn't have many of\n\t\t\t// the common properties so we use an identity check instead.\n\t\t\tif ( typeof document == 'object' && source === document ) return true;\n\t\t\treturn (\n\t\t\t\ttypeof source.nodeType === 'number' &&\n\t\t\t\tsource.attributes &&\n\t\t\t\tsource.childNodes &&\n\t\t\t\tsource.cloneNode\n\t\t\t);\n\t\t}\n\t}\n\n//\t Node copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) { return isNode(source); },\n\n\t\tcreate: function(source) {\n//\t\t\t there can only be one (document).\n\t\t\tif (typeof document == 'object' && source === document ) return document;\n\n//\t\t\t start with a shallow copy.  We'll handle the deep copy of\n//\t\t\t its children ourselves.\n\t\t\treturn source.cloneNode(false);\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n//\t\t\t we're not copying the global document, so don't have to populate it either.\n\t\t\tif ( typeof document == 'object' && source === document ) return document;\n\n//\t\t\t if this Node has children, deep copy them one-by-one.\n\t\t\tif ( source.childNodes && source.childNodes.length ) {\n\t\t\t\tfor ( var i=0; i<source.childNodes.length; i++ ) {\n\t\t\t\t\tvar childCopy = deepCopy(source.childNodes[i]);\n\t\t\t\t\tresult.appendChild(childCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n// Code.js : Fase Dictionary\n\tdeepCopy.register( {\n\t\tcanCopy: function(source) { return source._className == 'Dictionary'; },\n\t\tcreate: function(source) {\n\t\t\treturn new Dictionary();\n\t\t},\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var i in source._keys ){\n\t\t\t\tresult._keys[ i ] = source._keys[ i ];\n\t\t\t\tresult._values[ i ] = deepCopy( source.values[ i ])\n\t\t\t};\n\t\t}\n\t});\nreturn Code;\n})();"]],"start1":0,"start2":0,"length1":0,"length2":29706}]],"length":29706}
{"contributors":[],"silentsave":false,"ts":1357499332750,"patch":[[{"diffs":[[0,"dustries"],[1," http://www.neuromantic.com"],[0,"\n * Lice"]],"start1":154,"start2":154,"length1":16,"length2":43},{"diffs":[[0,"license."],[1,"\n\n * The original concept for this project and early versions of the code (as FaseJS) was co-created by\n * Ross Sclafani, http://ross.sclafani.net and Edward Hotckiss, http://www.edwardhotchkiss.com/\n * (Hotchkiss is also attributed in some parts of this code as `For Sure, Rad!`)\n * \n * Many thanks to the original authors, and the Open Source Software community."],[0,"\n *\n */\n"]],"start1":216,"start2":216,"length1":16,"length2":380},{"diffs":[[0,"on () {}"],[-1,""],[0,""],[1,";\n    var fs, path, ast, ugg, http"],[0,";\n\tif ( "]],"start1":782,"start2":782,"length1":16,"length2":50},{"diffs":[[0,"ly/4U5H\n"],[1,"\t * \n"],[0,"\t *\t\n\t *"]],"start1":9173,"start2":9173,"length1":16,"length2":21}]],"length":30136,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357499994440,"patch":[[{"diffs":[[0,"aseJS) w"],[-1,"as"],[1,"ere"],[0," co-crea"]],"start1":303,"start2":303,"length1":18,"length2":19}]],"length":30137,"saved":false}
{"ts":1357500187500,"patch":[[{"diffs":[[0," [ className ];\n"],[-1,"//"],[0,"_debug( 'adding "]],"start1":6909,"start2":6909,"length1":34,"length2":32},{"diffs":[[0,"lassName );\n"],[1,""],[0,"\t\t\t\t\tglobal."]],"start1":6950,"start2":6950,"length1":24,"length2":24},{"diffs":[[0,"unction("],[-1," classPath, immediately"],[0," ) {//--"]],"start1":7416,"start2":7416,"length1":39,"length2":16},{"diffs":[[0," define\n"],[-1,"//"],[0,"_debug( "]],"start1":7668,"start2":7668,"length1":18,"length2":16},{"diffs":[[0,"lassName );\n"],[1,""],[0,"\t\t\t\tif( glob"]],"start1":7695,"start2":7695,"length1":24,"length2":24},{"diffs":[[0,"perties ) {\n"],[-1,"//"],[0,"_debug( '_ex"]],"start1":7969,"start2":7969,"length1":26,"length2":24}]],"length":30108,"saved":false}
{"ts":1357500198661,"patch":[[{"diffs":[[0,"ure Use\n"],[-1,"// "],[0,"_trace( "]],"start1":8943,"start2":8943,"length1":19,"length2":16}]],"length":30105,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357504682619,"patch":[[{"diffs":[[0,"n( classPath"],[-1,", immediately"],[0," ) {//------"]],"start1":2751,"start2":2751,"length1":37,"length2":24},{"diffs":[[0,"Path"],[-1,", first"],[0," ) {"]],"start1":3432,"start2":3432,"length1":15,"length2":8}]],"length":30085,"saved":false}
{"ts":1357504824347,"patch":[[{"diffs":[[0,"ssName;\n"],[-1,"\t\t\t\t"],[1,"                "],[0,"while ( "]],"start1":6533,"start2":6533,"length1":20,"length2":32},{"diffs":[[0,"/ while\n"],[-1,"\t\t\t\t"],[1,"               "],[0," _.inter"]],"start1":6635,"start2":6635,"length1":20,"length2":31},{"diffs":[[0,"sses();\n"],[-1,"\t\t\t\t"],[1,"               "],[0," this._q"]],"start1":6682,"start2":6682,"length1":20,"length2":31}]],"length":30119,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357595836238,"patch":[[{"diffs":[[0,"rver\n\t\t\t\t\t\ttry{\n"],[-1,"//"],[0,""],[1,""],[0,"_debug( 'looking"]],"start1":3679,"start2":3679,"length1":34,"length2":32},{"diffs":[[0,"catch( e ){\n"],[-1,"//"],[0,"_debug( 'no "]],"start1":3790,"start2":3790,"length1":26,"length2":24},{"diffs":[[0,"');\n\t\t\t\t\t\t\ttry{\n"],[-1,"//"],[0,"_debug( 'loading"]],"start1":3833,"start2":3833,"length1":34,"length2":32},{"diffs":[[0,"\t\t\ttry{\n"],[-1,"//"],[0,""],[1,""],[0,"_debug( "]],"start1":3959,"start2":3959,"length1":18,"length2":16},{"diffs":[[0,"\n\t\t\t\t\t\t\t\t\t}\n"],[-1,"//"],[0,""],[1,""],[0,"_debug( 'wri"]],"start1":4482,"start2":4482,"length1":26,"length2":24},{"diffs":[[0,"tion\" )\n"],[-1,"//"],[0,""],[1,""],[0,"_debug( "]],"start1":4855,"start2":4855,"length1":18,"length2":16},{"diffs":[[0,";\n\t\t\t\t}\n"],[-1,"//"],[0,""],[1,""],[0,"_debug( "]],"start1":5362,"start2":5362,"length1":18,"length2":16},{"diffs":[[0," ] || {}"],[-1,""],[0,""],[1,";"],[0,"\n\t\t\t\tglo"]],"start1":5869,"start2":5869,"length1":16,"length2":17},{"diffs":[[0,": function () {\n"],[-1,"//"],[0,"_debug( 'compili"]],"start1":6460,"start2":6460,"length1":34,"length2":32}]],"length":30104,"saved":false}
{"ts":1357595977350,"patch":[[{"diffs":[[0,"Path"],[-1,", immediately"],[0," ) {"]],"start1":6229,"start2":6229,"length1":21,"length2":8},{"diffs":[[0,"unction("],[-1," className"],[0," ) {\n\t\t\t"]],"start1":6354,"start2":6354,"length1":26,"length2":16},{"diffs":[[0,"ript );\n"],[-1,"//"],[0,"_debug( "]],"start1":7207,"start2":7207,"length1":18,"length2":16}]],"length":30079,"saved":false}
{"ts":1357596612788,"patch":[[{"diffs":[[0,"nction( ) {\n"],[1,"_debug( 'stubbing', className );\n"],[0,"\t\t\t\treturn {"]],"start1":6355,"start2":6355,"length1":24,"length2":57}]],"length":30112,"saved":false}
{"ts":1357598406146,"patch":[[{"diffs":[[0,"t : function"],[-1,"("],[1," ( classPath"],[0," ) {//------"]],"start1":7418,"start2":7418,"length1":25,"length2":36},{"diffs":[[0," (null)\n"],[1,"_debug( 'skipping import: ', classPath );\n"],[0,"\t\t\t},// "]],"start1":7531,"start2":7531,"length1":16,"length2":58}]],"length":30165,"saved":false}
{"ts":1357598438190,"patch":[[{"diffs":[[0,"unction("],[1," className"],[0," ) {\n_de"]],"start1":6354,"start2":6354,"length1":16,"length2":26}]],"length":30175,"saved":false}
{"ts":1357600253597,"patch":[[{"diffs":[[0,"lassPath"],[-1," "],[1,", 'source bytes =', code.length"],[0,");\t\n\t\t\t\t"]],"start1":4003,"start2":4003,"length1":17,"length2":47}]],"length":30205,"saved":false}
{"ts":1357600392814,"patch":[[{"diffs":[[0,"e.length"],[1," "],[0,");\t\n\t\t\t\t"]],"start1":4034,"start2":4034,"length1":16,"length2":17},{"diffs":[[0,"d names\n"],[1,"_debug( 'mangling', classPath );\n"],[0,"\t\t\t\t\t\t\t\t"]],"start1":4256,"start2":4256,"length1":16,"length2":49},{"diffs":[[0,"zations\n"],[1,"_debug( 'squeezing', classPath );\n"],[0,"\t\t\t\t\t\t\t\t"]],"start1":4388,"start2":4388,"length1":16,"length2":50}]],"length":30273,"saved":false}
{"ts":1357600488482,"patch":[[{"diffs":[[0,"'bin/' ) ){\n"],[1,"_debug( 'creating bin' );\n"],[0,"\t\t\t\t\t\t\t\t\t\tfs"]],"start1":4536,"start2":4536,"length1":24,"length2":50},{"diffs":[[0,"e to', binPath, "],[-1,"code"],[1,"'final bytes =', code.length"],[0," );\n\t\t\t\t\t\t\t\t\tfs."]],"start1":4642,"start2":4642,"length1":36,"length2":60}]],"length":30323,"saved":false}
{"ts":1357600784688,"patch":[[{"diffs":[[0," (stub)\n"],[-1,"//"],[0,"_debug( "]],"start1":3113,"start2":3113,"length1":18,"length2":16},{"diffs":[[0,"( 's"],[-1,"tubbing', "],[1,"kipping _"],[0,"class"],[-1,"Name"],[1,"'"],[0," );\n"]],"start1":6529,"start2":6529,"length1":27,"length2":23}]],"length":30317,"saved":false}
{"ts":1357600900806,"patch":[[{"diffs":[[0,"perName ) {\n"],[1,"_debug( 'which extends', superName)\n"],[0,"\t\t\t\t\t\tthis._"]],"start1":3215,"start2":3215,"length1":24,"length2":60}]],"length":30353,"saved":false}
{"ts":1357601911790,"patch":[[{"diffs":[[0,"ng();\n\t\t\t\t}\n"],[1,"                var s;\n"],[0,"\t\t\t\tswitch( "]],"start1":1364,"start2":1364,"length1":24,"length2":47},{"diffs":[[0,"ect':\n\t\t\t\t\t\t"],[-1,"var "],[0,"s = '{ ';\n\t\t"]],"start1":1438,"start2":1438,"length1":28,"length2":24},{"diffs":[[0,"ray':\n\t\t\t\t\t\t"],[-1,"var "],[0,"s = '[ ';\n\t\t"]],"start1":1928,"start2":1928,"length1":28,"length2":24}]],"length":30368,"saved":false}
{"ts":1357601936118,"patch":[[{"diffs":[[0,"   var s"],[1,", val"],[0,";\n\t\t\t\tsw"]],"start1":1389,"start2":1389,"length1":16,"length2":21},{"diffs":[[0,"n obj ){\n\t\t\t\t\t\t\t"],[-1,"var "],[0,"val = obj[key];\n"]],"start1":1485,"start2":1485,"length1":36,"length2":32}]],"length":30369,"saved":false}
{"ts":1357601983758,"patch":[[{"diffs":[[0,"fined;\n\t\t\t\t}"],[-1,";"],[0,"\n\t\t\t\treturn "]],"start1":9901,"start2":9901,"length1":25,"length2":24},{"diffs":[[0,"value;\n\t\t\t\t}"],[-1,";"],[0,"\n\t\t\t\n\t\t\t},\n\t"]],"start1":10298,"start2":10298,"length1":25,"length2":24},{"diffs":[[0,"value;\n\t\t\t\t}"],[-1,";"],[0,"\n\t\t\t},\n\t\t\tto"]],"start1":10643,"start2":10643,"length1":25,"length2":24}]],"length":30366,"saved":false}
{"ts":1357602016760,"patch":[[{"diffs":[[0,"is it a "],[-1," "],[0,"property"]],"start1":9615,"start2":9615,"length1":17,"length2":16},{"diffs":[[0,"rty or a get"],[1,"ter"],[0,"Setter ? )\n\t"]],"start1":9628,"start2":9628,"length1":24,"length2":27}]],"length":30368,"saved":false}
{"ts":1357602033339,"patch":[[{"diffs":[[0,"_init__'"],[1,";"],[0,"\n\t\t\t} el"]],"start1":12989,"start2":12989,"length1":16,"length2":17},{"diffs":[[0,"pe;\n\t\t\t}"],[-1,";"],[0,"\n\n\t\t\tvar"]],"start1":13072,"start2":13072,"length1":17,"length2":16}]],"length":30368,"saved":false}
{"ts":1357602154761,"patch":[[{"diffs":[[0,"unction() {\n"],[1,"_debug( className+'.'+propertyName )\n"],[0,"\t\t\t         "]],"start1":13257,"start2":13257,"length1":24,"length2":61}]],"length":30405,"saved":false}
{"ts":1357602176632,"patch":[[{"diffs":[[0,"opertyName )"],[1,";"],[0,"\n\t\t\t        "]],"start1":13293,"start2":13293,"length1":24,"length2":25}]],"length":30406,"saved":false}
{"ts":1357602589033,"patch":[[{"diffs":[[0,"e;\n\t\t\t}\n"],[-1,"\n"],[0,"\t\t\tvar p"]],"start1":13073,"start2":13073,"length1":17,"length2":16},{"diffs":[[0,"n'  ) {\n"],[-1,"\t\t"],[1,"          "],[0,"      "],[-1,"\t"],[0,"property"]],"start1":13133,"start2":13133,"length1":25,"length2":32},{"diffs":[[0,"n';\n"],[-1,"\t\t"],[0,"      "],[-1,"\t"],[1,"          "],[0,"prop"]],"start1":13180,"start2":13180,"length1":17,"length2":24},{"diffs":[[0,"uper ){\n"],[-1,"\t\t\t"],[1,"     "],[0,"        "],[1,"   "],[0,"return f"]],"start1":13243,"start2":13243,"length1":27,"length2":32},{"diffs":[[0,"unction() {\n"],[1,"                    var args = '';\n                    for(var i in arguments){\n                        args += _.util.stringify( arguments[ i ])+',';\n                    }\n                    args = args.slice(0, -1);\n"],[0,"_debug( clas"]],"start1":13275,"start2":13275,"length1":24,"length2":243},{"diffs":[[0,"propertyName"],[1,"+'( '+args+' )'"],[0," );\n\t\t\t     "]],"start1":13528,"start2":13528,"length1":24,"length2":39}]],"length":30658,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357616281278,"patch":[[{"diffs":[[0,"cope"],[-1,", functionName"],[0,""],[1,""],[0," ) {"]],"start1":2264,"start2":2264,"length1":22,"length2":8},{"diffs":[[0,"s[i]+\",\""],[1,";"],[0,"\n\t\t\t\t\t}\n"]],"start1":2382,"start2":2382,"length1":16,"length2":17},{"diffs":[[0,"ng(0,-1)"],[1,";"],[0,"\n// _deb"]],"start1":2417,"start2":2417,"length1":16,"length2":17},{"diffs":[[0," ')' );\n"],[-1,"\t\t\t\t\t"],[1,"                   "],[0," return "]],"start1":2474,"start2":2474,"length1":21,"length2":35},{"diffs":[[0,"ents );\n"],[-1,"\t\t\t\t"],[1,"                "],[0,"}//closu"]],"start1":2531,"start2":2531,"length1":20,"length2":32},{"diffs":[[0,"re Use\n_"],[-1,"trace"],[1,"debug"],[0,"( 'packa"]],"start1":9222,"start2":9222,"length1":21,"length2":21}]],"length":30672,"saved":false}
{"ts":1357616790933,"patch":[[{"diffs":[[0,"       }"],[1,";"],[0,"//closur"]],"start1":2548,"start2":2548,"length1":16,"length2":17}]],"length":30673,"saved":false}
{"ts":1357616846154,"patch":[[{"diffs":[[0,"nction () {\n"],[1,"//"],[0,"\t\t\t\t\tvar s ="]],"start1":2286,"start2":2286,"length1":24,"length2":26},{"diffs":[[0,"var s = '';\n"],[1,"//"],[0,"\t\t\t\t\tfor (va"]],"start1":2305,"start2":2305,"length1":24,"length2":26},{"diffs":[[0,"gth; i++) {\n"],[1,"//"],[0,"\t\t\t\t\t\ts+=arg"]],"start1":2357,"start2":2357,"length1":24,"length2":26},{"diffs":[[0,"nts["],[-1,"i"],[1," i "],[0,"]+\",\";\n"],[1,"//"],[0,"\t\t\t\t\t}\n"],[1,"//"],[0,"\t\t\t\t"]],"start1":2386,"start2":2386,"length1":23,"length2":29},{"diffs":[[0,",-1);\n//"],[-1," "],[0,"_debug( "]],"start1":2433,"start2":2433,"length1":17,"length2":16}]],"length":30684,"saved":false}
{"ts":1357618170690,"patch":[[{"diffs":[[0," ){\n"],[-1,"\t\t\t\tif ( typeof obj === 'undefined' ){\n\t\t\t\t\treturn '{undefined}';\n\t\t\t\t}\n"],[0,"\t\t\t\t"]],"start1":1117,"start2":1117,"length1":80,"length2":8},{"diffs":[[0," null){\n"],[1,""],[0,"\t\t\t\t\tret"]],"start1":1137,"start2":1137,"length1":16,"length2":16},{"diffs":[[0,"ll}';\n\t\t\t\t}\n"],[-1,"\t\t\t\t\n"],[0,"\t\t\t\tif ( obj"]],"start1":1161,"start2":1161,"length1":29,"length2":24},{"diffs":[[0,"   var s"],[1," = ( typeof obj ).substring( 0, 1 )"],[0,", val;\n\t"]],"start1":1312,"start2":1312,"length1":16,"length2":51},{"diffs":[[0,"\t\t\t\t\t\ts "],[1,"+"],[0,"= '{ ';\n"]],"start1":1407,"start2":1407,"length1":16,"length2":17},{"diffs":[[0,"return '"],[-1,"["],[1,"{"],[0,"function"],[-1,"]"],[1,"}"],[0,"';\n\t\t\t\t\t"]],"start1":1854,"start2":1854,"length1":26,"length2":26},{"diffs":[[0,"\t\t\t\t\t\ts "],[1,"+"],[0,"= '[ ';\n"]],"start1":1894,"start2":1894,"length1":16,"length2":17},{"diffs":[[0,"+=' ]';\n"],[-1,""],[0,"\t\t\t\t\t\tre"]],"start1":2106,"start2":2106,"length1":16,"length2":16},{"diffs":[[0,"\t\t\treturn s\n"],[1,"                    case  'undefined' :\n                        return '{undefined}';\n"],[0,"\t\t\t\t\tdefault"]],"start1":2117,"start2":2117,"length1":24,"length2":110}]],"length":30730,"saved":false}
{"ts":1357618304698,"patch":[[{"diffs":[[0,"bj, done ){\n"],[1,"                if( typeof obj === 'undefined'){\n                    return '{undefined}';\n                }\n"],[0,"\t\t\t\tif ( obj"]],"start1":1109,"start2":1109,"length1":24,"length2":133},{"diffs":[[0,"n s\n"],[-1,"                    case  'undefined' :\n                        return '{undefined}';\n"],[0,"\t\t\t\t"]],"start1":2234,"start2":2234,"length1":94,"length2":8}]],"length":30753,"saved":false}
{"ts":1357618951627,"patch":[[{"diffs":[[0,"s = "],[-1,"( typeof obj ).substring( 0, 1 ), val;"],[1,"'', val;\n                if (obj instancof Array){\n                    s += '[ ';\n\t\t\t\t\tfor (var i = 0; i < obj.length; i++ ){\n\t\t\t\t\t\tvar val = obj[i];\n\t\t\t\t\t\tval = _.util.stringify(val, true);\n\t\t\t\t\t\ts+= ' ' + key + ' : ' + val + ',' ;\n\t\t\t\t\t}\n\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\ts+=' ]';\n\t\t\t\t\treturn s\n                }"],[0,"\n\t\t\t"]],"start1":1428,"start2":1428,"length1":46,"length2":317},{"diffs":[[0,"}';\n"],[-1,"\t\t\t\t\tcase 'array':\n\t\t\t\t\t\ts += '[ ';\n\t\t\t\t\t\tfor (var i = 0; i < obj.length; i++ ){\n\t\t\t\t\t\t\tvar val = obj[i];\n\t\t\t\t\t\t\tval = _.util.stringify(val, true);\n\t\t\t\t\t\t\ts+= ' ' + key + ' : ' + val + ',' ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\t\ts+=' ]';\n\t\t\t\t\t\treturn s\n"],[0,"\t\t\t\t"]],"start1":2251,"start2":2251,"length1":262,"length2":8}]],"length":30770,"saved":false}
{"ts":1357618980000,"patch":[[{"diffs":[[0," instanc"],[1,"e"],[0,"of Array"]],"start1":1464,"start2":1464,"length1":16,"length2":17}]],"length":30771,"saved":false}
{"ts":1357619074717,"patch":[[{"diffs":[[0,"{\n\t\t\t\t\t\t"],[-1,"var "],[0,"val = ob"]],"start1":1557,"start2":1557,"length1":20,"length2":16}]],"length":30767,"saved":false}
{"ts":1357619130848,"patch":[[{"diffs":[[0,".util.stringify("],[1," "],[0,"val, true);\n\t\t\t\t"]],"start1":1592,"start2":1592,"length1":32,"length2":33},{"diffs":[[0,"ngify( val, true"],[1," "],[0,");\n\t\t\t\t\t\ts+= ' '"]],"start1":1602,"start2":1602,"length1":32,"length2":33}]],"length":30769,"saved":false}
{"ts":1357619149107,"patch":[[{"diffs":[[0,"return s"],[1,";"],[0,"\n       "]],"start1":1714,"start2":1714,"length1":16,"length2":17}]],"length":30770,"saved":false}
{"ts":1357619186449,"patch":[[{"diffs":[[0,"peof obj"],[1," "],[0,"){\n\t\t\t\t\t"]],"start1":1756,"start2":1756,"length1":16,"length2":17}]],"length":30771,"saved":false}
{"ts":1357619503565,"patch":[[{"diffs":[[0,";\n\t\t\t\t\t\ts+= "],[-1,"' ' + key + ' :"],[0," ' + val + '"]],"start1":1620,"start2":1620,"length1":39,"length2":24}]],"length":30756,"saved":false}
{"ts":1357619522715,"patch":[[{"diffs":[[0,"\t\t\t\ts+= "],[-1," ' +"],[0," val + '"]],"start1":1624,"start2":1624,"length1":20,"length2":16}]],"length":30752,"saved":false}
{"ts":1357619576045,"patch":[[{"diffs":[[0,"T CUTE.\n"],[-1,"\t\t"],[1,"    \n    "],[0,"\n\t/* \n\t "]],"start1":9377,"start2":9377,"length1":18,"length2":25}]],"length":30759,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357624813976,"patch":[[{"diffs":[[0,"quire =="],[1,"="],[0," 'functi"]],"start1":842,"start2":842,"length1":16,"length2":17},{"diffs":[[0,"bj, done ){\n"],[1,"                if( obj.toString() == obj){\n                    return obj\n                }\n"],[0,"            "]],"start1":1110,"start2":1110,"length1":24,"length2":117},{"diffs":[[0,"=== null"],[1," "],[0,"){\n\t\t\t\t\t"]],"start1":1337,"start2":1337,"length1":16,"length2":17}]],"length":30854,"saved":false}
{"ts":1357624860014,"patch":[[{"diffs":[[0,"al ="],[-1," type === 'string' ?  '\"' + obj +'\"' :"],[0," _.u"]],"start1":2096,"start2":2096,"length1":46,"length2":8}]],"length":30816,"saved":false}
{"ts":1357624903501,"patch":[[{"diffs":[[0," ){\n"],[-1,"                if( obj.toString() == obj){\n                    return obj\n                }\n"],[0,"    "]],"start1":1118,"start2":1118,"length1":101,"length2":8},{"diffs":[[0,"'{null}';\n\t\t\t\t}\n"],[1,"                if( obj.toString() == obj){\n                    return obj\n                }\n"],[0,"\t\t\t\tif ( obj.tag"]],"start1":1268,"start2":1268,"length1":32,"length2":125},{"diffs":[[0,"Name + '"],[-1,"/"],[0,">';\n\t\t\t\t"]],"start1":1425,"start2":1425,"length1":17,"length2":16}]],"length":30815,"saved":false}
{"ts":1357624961072,"patch":[[{"diffs":[[0,"      return"],[1," '?' +"],[0," obj\n       "]],"start1":1342,"start2":1342,"length1":24,"length2":30}]],"length":30821,"saved":false}
{"ts":1357625020378,"patch":[[{"diffs":[[0,"turn"],[-1," '?' +"],[0," obj"]],"start1":1350,"start2":1350,"length1":14,"length2":8}]],"length":30815,"saved":false}
{"ts":1357625035614,"patch":[[{"diffs":[[0,"     if("],[1," obj.toString &&"],[0," obj.toS"]],"start1":1295,"start2":1295,"length1":16,"length2":32}]],"length":30831,"saved":false}
{"ts":1357625045917,"patch":[[{"diffs":[[0,"bj, done ){\n"],[1,"                if( obj.toString && obj.toString() == obj){\n                    return obj\n                }\n"],[0,"            "]],"start1":1110,"start2":1110,"length1":24,"length2":133},{"diffs":[[0,"\t\t}\n"],[-1,"                if( obj.toString && obj.toString() == obj){\n                    return obj\n                }\n"],[0,"\t\t\t\t"]],"start1":1389,"start2":1389,"length1":117,"length2":8}]],"length":30831,"saved":false}
{"ts":1357625050836,"patch":[[{"diffs":[[0,"turn obj"],[1,";"],[0,"\n       "]],"start1":1204,"start2":1204,"length1":16,"length2":17}]],"length":30832,"saved":false}
{"ts":1357625097248,"patch":[[{"diffs":[[0," ){\n"],[-1,"                if( obj.toString && obj.toString() == obj){\n                    return obj;\n                }\n"],[0,"    "]],"start1":1118,"start2":1118,"length1":118,"length2":8},{"diffs":[[0,"'{null}';\n\t\t\t\t}\n"],[1,"                if( obj.toString && obj.toString() == obj){\n                    return obj;\n                }\n"],[0,"\t\t\t\tif ( obj.tag"]],"start1":1268,"start2":1268,"length1":32,"length2":142}]],"length":30832,"saved":false}
{"ts":1357625477249,"patch":[[{"diffs":[[0,"\t\t}\n"],[-1,"                if( obj.toString && obj.toString() == obj){\n                    return obj;\n                }\n"],[0,"\t\t\t\t"]],"start1":1280,"start2":1280,"length1":118,"length2":8},{"diffs":[[0,";\n\t\t\t\t}\n"],[1,"                if( obj.toString && obj.toString() == obj){\n                    return obj;\n                }\n"],[0,"        "]],"start1":1401,"start2":1401,"length1":16,"length2":126}]],"length":30832,"saved":false}
{"ts":1357625815115,"patch":[[{"diffs":[[0,"me + '>';\n\t\t\t\t}\n"],[1,"//"],[0,"\t\t\t\tif (obj._cla"]],"start1":1334,"start2":1334,"length1":32,"length2":34},{"diffs":[[0,"className){\n"],[1,"//"],[0,"\t\t\t\t\treturn "]],"start1":1365,"start2":1365,"length1":24,"length2":26},{"diffs":[[0,"();\n"],[1,"//"],[0,"\t\t\t\t}\n"],[-1,"                if( obj.toString && obj.toString() == obj){\n                    return obj;\n                }\n"],[0,"    "]],"start1":1403,"start2":1403,"length1":124,"length2":16}]],"length":30728,"saved":false}
{"ts":1357625915402,"patch":[[{"diffs":[[0,"== '"],[-1,"array' || type === '"],[1,"{"],[0,"object"],[1,"}"],[0,"' ||"]],"start1":1914,"start2":1914,"length1":34,"length2":16},{"diffs":[[0,"| type === '"],[1,"{"],[0,"function"],[1,"}"],[0,"' ) ? type :"]],"start1":1929,"start2":1929,"length1":32,"length2":34}]],"length":30712,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357629684997,"patch":[[{"diffs":[[0,"n, scope"],[1,", functionName"],[0," ) {\n\t\t\t"]],"start1":2281,"start2":2281,"length1":16,"length2":30},{"diffs":[[0,"perty =="],[1,"="],[0," 'functi"]],"start1":2688,"start2":2688,"length1":16,"length2":17},{"diffs":[[0,"\t\t\t\t\tif("],[1,"!"],[0," ! _.deb"]],"start1":4163,"start2":4163,"length1":16,"length2":17},{"diffs":[[0,"reate: function("],[-1,"source"],[0,") {\n\t\t\treturn ne"]],"start1":30454,"start2":30454,"length1":38,"length2":32}]],"length":30722,"saved":false}
{"ts":1357630458632,"patch":[[{"diffs":[[0," 'ascii' );\n"],[1,"                                code = code.substring( 0, -1 ) === ';' ? code : code + ';';\n"],[0,"\t\t\t\t\t\t\t\ttry{"]],"start1":4054,"start2":4054,"length1":24,"length2":116},{"diffs":[[0,"' );\n\t\t}"],[-1,";"],[0,"// for\n\t"]],"start1":9190,"start2":9190,"length1":17,"length2":16},{"diffs":[[0,"n document;\n"],[-1,"\n"],[0,"//\t\t\t start "]],"start1":29776,"start2":29776,"length1":25,"length2":24},{"diffs":[[0,"de(false);\n\t\t},\n"],[1,"        "],[0,"\n"],[-1,""],[0,"\t\tpopulate: func"]],"start1":29906,"start2":29906,"length1":33,"length2":41},{"diffs":[[0,"cument;\n"],[-1,"\n"],[0,"//\t\t\t if"]],"start1":30132,"start2":30132,"length1":17,"length2":16},{"diffs":[[0,"\t\t}\n\t\t}\n"],[-1,""],[0,"\t});\n"],[1,"    \n"],[0,"// Code."]],"start1":30409,"start2":30409,"length1":21,"length2":26}]],"length":30824,"saved":false}
{"ts":1357630695893,"patch":[[{"diffs":[[0,"      code ="],[1," ("],[0," code.substr"]],"start1":4092,"start2":4092,"length1":24,"length2":26},{"diffs":[[0,"e.substr"],[-1,"ing"],[0,"( 0, -1 "]],"start1":4110,"start2":4110,"length1":19,"length2":16},{"diffs":[[0," === ';'"],[1," )"],[0," ? code "]],"start1":4127,"start2":4127,"length1":16,"length2":18},{"diffs":[[0,"? code :"],[1," ("],[0," code + "]],"start1":4138,"start2":4138,"length1":16,"length2":18},{"diffs":[[0,"de + ';'"],[1," )"],[0,";\n\t\t\t\t\t\t"]],"start1":4151,"start2":4151,"length1":16,"length2":18}]],"length":30829,"saved":false}
{"ts":1357630767974,"patch":[[{"diffs":[[0," );\n"],[-1,"                                code = ( code.substr( 0, -1 ) === ';' ) ? code : ( code + ';' );\n"],[0,"\t\t\t\t"]],"start1":4062,"start2":4062,"length1":105,"length2":8},{"diffs":[[0,"ode here"],[-1,"\t"],[1,"\n                                        \n                                        code = ( code.substr( 0, -1 ) === ';' ) ? code : ( code + ';' );"],[0,"\n\t\t\t\t\t\t\t"]],"start1":4597,"start2":4597,"length1":17,"length2":162}]],"length":30877,"saved":false}
{"ts":1357631580871,"patch":[[{"diffs":[[0,"\t\t\t\tif(!"],[-1," !"],[0," _.debug"]],"start1":4164,"start2":4164,"length1":18,"length2":16}]],"length":30875,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357756153594,"patch":[[{"diffs":[[0,"gging : "],[-1,"tru"],[1,"fals"],[0,"e,\n\t\tapp"]],"start1":1039,"start2":1039,"length1":19,"length2":20},{"diffs":[[0,"(0,-1);\n"],[-1,"//_debug"],[1,"_verbose"],[0,"( scope "]],"start1":2467,"start2":2467,"length1":24,"length2":24},{"diffs":[[0,"(stub)\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'creat"]],"start1":3193,"start2":3193,"length1":21,"length2":23},{"diffs":[[0,"me ) {\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'which"]],"start1":3301,"start2":3301,"length1":21,"length2":23},{"diffs":[[0,"\t\t\t\t\t\ttry{\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'looking f"]],"start1":3801,"start2":3801,"length1":29,"length2":31},{"diffs":[[0,"atch( e ){\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'no byteco"]],"start1":3910,"start2":3910,"length1":29,"length2":31},{"diffs":[[0,"\t\ttry{\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'loadi"]],"start1":3963,"start2":3963,"length1":21,"length2":23},{"diffs":[[0,"\t\ttry{\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'gener"]],"start1":4083,"start2":4083,"length1":21,"length2":23},{"diffs":[[0," names\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'mangl"]],"start1":4381,"start2":4381,"length1":21,"length2":23},{"diffs":[[0,"ations\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'squee"]],"start1":4515,"start2":4515,"length1":21,"length2":23},{"diffs":[[0,"' ) ){\n_"],[-1,"debug"],[1,"info"],[0,"( 'creat"]],"start1":4814,"start2":4814,"length1":21,"length2":20},{"diffs":[[0,"\t\t\t\t\t}\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'writi"]],"start1":4883,"start2":4883,"length1":21,"length2":23},{"diffs":[[0,"ror );\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'error"]],"start1":5061,"start2":5061,"length1":21,"length2":23},{"diffs":[[0,"ror ){\n_"],[-1,"debug"],[1,"error"],[0,"( 'file "]],"start1":5134,"start2":5134,"length1":21,"length2":21},{"diffs":[[0,"ion\" )\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'strea"]],"start1":5280,"start2":5280,"length1":21,"length2":23},{"diffs":[[0,"lse if\n_"],[-1,"debug"],[1,"error"],[0,"( 'XMLHt"]],"start1":5582,"start2":5582,"length1":21,"length2":21},{"diffs":[[0,"atch( error ){\n_"],[-1,"debug"],[1,"error"],[0,"( 'error loading"]],"start1":5698,"start2":5698,"length1":37,"length2":37},{"diffs":[[0,"\n\t\t\t\t}\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'loade"]],"start1":5789,"start2":5789,"length1":21,"length2":23},{"diffs":[[0,"ror ){\n_"],[-1,"debug"],[1,"error"],[0,"( 'error"]],"start1":6084,"start2":6084,"length1":21,"length2":21},{"diffs":[[0,"me ) {\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'skipp"]],"start1":6798,"start2":6798,"length1":21,"length2":23},{"diffs":[[0,"n () {\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'compi"]],"start1":6915,"start2":6915,"length1":21,"length2":23},{"diffs":[[0,"ame ];\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'addin"]],"start1":7365,"start2":7365,"length1":21,"length2":23},{"diffs":[[0,"ipt );\n_"],[-1,"debug"],[1,"verbose"],[0,"( this.b"]],"start1":7681,"start2":7681,"length1":21,"length2":23},{"diffs":[[0,"(null)\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'skipp"]],"start1":7974,"start2":7974,"length1":21,"length2":23},{"diffs":[[0,"define\n_"],[-1,"debug"],[1,"verbose"],[0,"( '_clas"]],"start1":8173,"start2":8173,"length1":21,"length2":23},{"diffs":[[0,"es ) {\n_"],[-1,"debug"],[1,"verbose"],[0,"( '_exte"]],"start1":8480,"start2":8480,"length1":21,"length2":23},{"diffs":[[0,"on () {\n"],[-1,"//_debug"],[1,"_verbose"],[0,"( 'defin"]],"start1":8852,"start2":8852,"length1":24,"length2":24},{"diffs":[[0,"};// _\n\t"],[-1,""],[0,""],[1,"var DebugLevels = {\n        SILENT  : 0,\n        ERRORS  : 1,\n        WARNINGS: 2,\n        DEBUG   : 3,\n        INFO    : 4,\n        VERBOSE : 5\n\t};"],[0,"\n\t_trace"]],"start1":9105,"start2":9105,"length1":16,"length2":164},{"diffs":[[0,"e\n\t\n"],[-1,"\t_debug = function () {\n\t\tif( _.debugging"],[1,"    _error = function () {\n\t\tif( _.debugging >= DebugLevels.ERRORS ) _trace.apply( this, arguments );\n\t};//\n    _warn = function () {\n\t\tif( _.debugging >= DebugLevels.WARNINGS ) _trace.apply( this, arguments );\n\t};//\n    _info = function () {\n\t\tif( _.debugging >= DebugLevels.INFO ) _trace.apply( this, arguments );\n\t};//\n    _verbose = function () {\n    \tif( _.debugging >= DebugLevels.DEBUG ) _trace.apply( this, arguments );\n\t};//\n    _verbose = function () {\n    \tif( _.debugging >= DebugLevels.VERBOSE"],[0," ) _"]],"start1":9478,"start2":9478,"length1":49,"length2":514},{"diffs":[[0,"re Use\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'packa"]],"start1":10064,"start2":10064,"length1":21,"length2":23},{"diffs":[[0,", -1);\n_"],[-1,"debug"],[1,"verbose"],[0,"( classN"]],"start1":14364,"start2":14364,"length1":21,"length2":23},{"diffs":[[0,"perty;\n_"],[-1,"debug"],[1,"verbose"],[0,"('\\t', p"]],"start1":15866,"start2":15866,"length1":21,"length2":23},{"diffs":[[0,"ndex ];\n"],[-1,"//_debug("],[1,"_verbose"],[0," 'proper"]],"start1":16114,"start2":16114,"length1":25,"length2":24},{"diffs":[[0,"Name ];\n"],[-1,"//_debug"],[1,"_verbose"],[0,"( 'gette"]],"start1":16217,"start2":16217,"length1":24,"length2":24},{"diffs":[[0,"Name ];\n"],[-1,"//_debug"],[1,"_verbose"],[0,"( 'sette"]],"start1":16316,"start2":16316,"length1":24,"length2":24},{"diffs":[[0,"ter ) {\n"],[-1,"//_debug"],[1,"_verbose"],[0,"( 'getti"]],"start1":16524,"start2":16524,"length1":24,"length2":24},{"diffs":[[0," ){\n"],[-1,"// _debug"],[1,"_verbose"],[0,"( 's"]],"start1":16673,"start2":16673,"length1":17,"length2":16},{"diffs":[[0,"ing ){\n_"],[-1,"debug"],[1,"verbose"],[0,"( 'new',"]],"start1":17139,"start2":17139,"length1":21,"length2":23},{"diffs":[[0,"ame) < 0 ){\n"],[-1,"//_debug"],[1,"_verbose"],[0,"( 'scoping p"]],"start1":17471,"start2":17471,"length1":32,"length2":32},{"diffs":[[0," ){\n"],[-1,"//_debug"],[1,"_verbose"],[0,"( 's"]],"start1":17747,"start2":17747,"length1":16,"length2":16},{"diffs":[[0,"meters ) {\n_"],[-1,"debug"],[1,"verbose"],[0,"('Code.r(',a"]],"start1":18445,"start2":18445,"length1":29,"length2":31},{"diffs":[[0,"ers ){\n_"],[-1,"debug"],[1,"verbose"],[0,"('Code.x"]],"start1":18757,"start2":18757,"length1":21,"length2":23},{"diffs":[[0,"th ) {\n_"],[-1,"debug"],[1,"verbose"],[0,"('Code.c"]],"start1":19183,"start2":19183,"length1":21,"length2":23},{"diffs":[[0,"){\n\t\t\t\t_"],[-1,"debug"],[1,"verbose"],[0,"( 'no li"]],"start1":19385,"start2":19385,"length1":21,"length2":23},{"diffs":[[0," () {\n\t_"],[-1,"debug"],[1,"verbose"],[0,"( 'bypas"]],"start1":19541,"start2":19541,"length1":21,"length2":23},{"diffs":[[0,"){\n\t\t\t\t_"],[-1,"debug"],[1,"verbose"],[0," (' fs &"]],"start1":19719,"start2":19719,"length1":21,"length2":23},{"diffs":[[0,"{\n\t\t\t\t\t_"],[-1,"debug"],[1,"verbose"],[0,"( 'creat"]],"start1":19787,"start2":19787,"length1":21,"length2":23},{"diffs":[[0,"\t\n\t\t\t\t\t_"],[-1,"debug"],[1,"verbose"],[0,"( 'savin"]],"start1":19864,"start2":19864,"length1":21,"length2":23},{"diffs":[[0,"ss;\n"],[-1,"\t_debug"],[1,"_info"],[0,"('Co"]],"start1":20152,"start2":20152,"length1":15,"length2":13},{"diffs":[[0,"e ready."],[1," @2013 Neuromantic, LLC. All Rights reserved. Licenced under the MIT license."],[0,"')\n\n////"]],"start1":20166,"start2":20166,"length1":16,"length2":93}]],"length":31623,"saved":false}
{"ts":1357756157044,"patch":[[{"diffs":[[0,"debugging : "],[-1,"false"],[1,"0"],[0,",\n\t\tapplicat"]],"start1":1035,"start2":1035,"length1":29,"length2":25}]],"length":31619,"saved":false}
{"ts":1357756223817,"patch":[[{"diffs":[[0,"\t};// _\n"],[-1,"\tvar "],[1,"global."],[0,"DebugLev"]],"start1":9100,"start2":9100,"length1":21,"length2":23}]],"length":31621,"saved":false}
{"ts":1357756547679,"patch":[[{"diffs":[[0,"s );\n\t};//\n    _"],[-1,"verbose"],[1,"debug"],[0," = function () {"]],"start1":9791,"start2":9791,"length1":39,"length2":37},{"diffs":[[0,"on () {\n"],[-1,"\t"],[0,"_verbose"]],"start1":19535,"start2":19535,"length1":17,"length2":16},{"diffs":[[0,"fo('Code"],[1,".js"],[0," ready. "]],"start1":20154,"start2":20154,"length1":16,"length2":19}]],"length":31621,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357756956449,"patch":[[{"diffs":[[0,"_verbose"],[1,"("],[0," 'proper"]],"start1":16118,"start2":16118,"length1":16,"length2":17}]],"length":31622,"saved":false}
{"ts":1357756996859,"patch":[[{"diffs":[[0,") {\n"],[-1,"//\t\t\t\t\tvar s = '';\n//\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n//\t\t\t\t\t\ts+=arguments[ i ]+\",\";\n//\t\t\t\t\t}\n//\t\t\t\t\ts = s.substring(0,-1);\n_verbose( scope + '.' + functionName+'(' + s + ')' );\n"],[0,"    "]],"start1":2326,"start2":2326,"length1":203,"length2":8}]],"length":31427,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357764673735,"patch":[[{"diffs":[[0,"ommunity"],[-1,"."],[1," at large"],[0,"\n *\n */\n"]],"start1":580,"start2":580,"length1":17,"length2":25}]],"length":31435,"saved":false}
{"ts":1357768326825,"patch":[[{"diffs":[[0,"de.js\n *"],[-1," "],[0,""],[1,""],[0,"\n * Clas"]],"start1":12,"start2":12,"length1":17,"length2":16},{"diffs":[[0,"cript\n *"],[-1," "],[0,""],[1,""],[0,"\n * http"]],"start1":66,"start2":66,"length1":17,"length2":16},{"diffs":[[0,"ad!`)\n *"],[-1," "],[0,""],[1,""],[0,"\n * Many"]],"start1":498,"start2":498,"length1":17,"length2":16},{"diffs":[[0," null };"],[-1," "],[0,""],[1,""],[0,"\n\tconsol"]],"start1":716,"start2":716,"length1":17,"length2":16},{"diffs":[[0,"stub = {"],[-1," "],[0,""],[1,""],[0,"\n\t\t\t\t\t_e"]],"start1":3063,"start2":3063,"length1":17,"length2":16},{"diffs":[[0,"ength );"],[-1,"\t"],[0,""],[1,""],[0,"\n\t\t\t\t\t\t\t"]],"start1":3966,"start2":3966,"length1":17,"length2":16},{"diffs":[[0,"ere\n"],[-1,"                                        "],[0,""],[1,""],[0,"\n   "]],"start1":4420,"start2":4420,"length1":48,"length2":8},{"diffs":[[0,"e\n\t\t\t\t\t}"],[-1,"  "],[0,""],[1,""],[0,"\n\t\t\t\t}ca"]],"start1":5444,"start2":5444,"length1":18,"length2":16},{"diffs":[[0," _trace\n"],[-1,"\t"],[0,""],[1,""],[0,"\n    _er"]],"start1":9235,"start2":9235,"length1":17,"length2":16},{"diffs":[[0,";\n\t};//\n"],[-1,"\t"],[0,""],[1,""],[0,"\n\t_packa"]],"start1":9782,"start2":9782,"length1":17,"length2":16},{"diffs":[[0,"package\n"],[-1,"\t\n\t"],[1,"\n"],[0,"\n\t// DON"]],"start1":9876,"start2":9876,"length1":19,"length2":17},{"diffs":[[0,"TE.\n"],[-1,"    \n    "],[1,"\n"],[0,"\n\t/*"],[-1," "],[0,"\n\t *"],[-1," "],[0,"\n\t *"]],"start1":9902,"start2":9902,"length1":27,"length2":17},{"diffs":[[0," 'Class'"],[-1," "],[0,"\n\t * ori"]],"start1":9946,"start2":9946,"length1":17,"length2":16},{"diffs":[[0,"hn Resig\n\t *"],[-1," "],[0,""],[1,""],[0,"\n\t * http://"]],"start1":9988,"start2":9988,"length1":25,"length2":24},{"diffs":[[0,"\n\t *"],[-1," "],[0,"\n\t *"],[-1,"\t"],[0,"\n\t */"],[-1,"\t"],[0,"\n//\t"]],"start1":10023,"start2":10023,"length1":20,"length2":17},{"diffs":[[0,"ation --"],[-1," "],[0,""],[1,""],[0,"\n\t  // p"]],"start1":10138,"start2":10138,"length1":17,"length2":16},{"diffs":[[0,"place +="],[-1," "],[0,""],[1,""],[0,"\n\t  var "]],"start1":10287,"start2":10287,"length1":17,"length2":16},{"diffs":[[0,";\n\t\t\t\t}\n"],[-1,"\t\t\t"],[0,""],[1,""],[0,"\n\t\t\t},\n\t"]],"start1":10910,"start2":10910,"length1":19,"length2":16},{"diffs":[[0,"'; }"],[-1," "],[0,""],[1,""],[0,"\n\t\t};\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t  "]],"start1":11323,"start2":11323,"length1":17,"length2":14},{"diffs":[[0,"s space\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\t// TO"]],"start1":11970,"start2":11970,"length1":18,"length2":16},{"diffs":[[0,"t = {};\n"],[-1,"\t\t\t"],[0,""],[1,""],[0,"\n\t\t// TO"]],"start1":12212,"start2":12212,"length1":19,"length2":16},{"diffs":[[0,"roper ?\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\t\tif ("]],"start1":12248,"start2":12248,"length1":18,"length2":16},{"diffs":[[0,"ments );"],[-1,"        "],[0,""],[1,""],[0,"\n\t\t\t    "]],"start1":15248,"start2":15248,"length1":24,"length2":16},{"diffs":[[0," );\n\t\t}\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\t// Cr"]],"start1":15672,"start2":15672,"length1":18,"length2":16},{"diffs":[[0,"erName);"],[-1,"\t\t\t"],[0,""],[1,""],[0,"\n\t\t\tvar "]],"start1":15874,"start2":15874,"length1":19,"length2":16},{"diffs":[[0,"etter) ;"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\t\tvar "]],"start1":15971,"start2":15971,"length1":18,"length2":16},{"diffs":[[0,"etter );"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\t\tnewP"]],"start1":16068,"start2":16068,"length1":18,"length2":16},{"diffs":[[0,"};//for\n"],[-1,"\t\t\t\t"],[0,""],[1,""],[0,"\n\t\t\t\tfor"]],"start1":17328,"start2":17328,"length1":20,"length2":16},{"diffs":[[0,"totype;\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\t// En"]],"start1":17838,"start2":17838,"length1":18,"length2":16},{"diffs":[[0,"Object;\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\t// An"]],"start1":17930,"start2":17930,"length1":18,"length2":16},{"diffs":[[0,"callee;\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n\t\tretur"]],"start1":18007,"start2":18007,"length1":18,"length2":16},{"diffs":[[0,"ct;\n\t};\n"],[-1,"\t\t\t"],[0,""],[1,""],[0,"\n\tvar Co"]],"start1":18034,"start2":18034,"length1":19,"length2":16},{"diffs":[[0,"Path );\n"],[-1,"\t\t\t\t"],[0,""],[1,""],[0,"\n\t};\n\tCo"]],"start1":18388,"start2":18388,"length1":20,"length2":16},{"diffs":[[0,"b/');\n\t\t\t\t}\n"],[-1,"\t\t\t\t"],[0,""],[1,""],[0,"\n\t\t\t\t\t_verbo"]],"start1":19542,"start2":19542,"length1":28,"length2":24},{"diffs":[[0,"rpreter;"],[-1,"\t"],[0,""],[1,""],[0,"\n\t\t}\n\t\tr"]],"start1":19696,"start2":19696,"length1":17,"length2":16},{"diffs":[[0," = Code;"],[-1,"\t"],[0,""],[1,""],[0,"\n\tglobal"]],"start1":19754,"start2":19754,"length1":17,"length2":16},{"diffs":[[0,"t and/or"],[-1," "],[0,""],[1,""],[0,"\n//\tmodi"]],"start1":20607,"start2":20607,"length1":17,"length2":16},{"diffs":[[0," version.\n//"],[-1,"\t"],[0,""],[1,""],[0,"\n//\tOWL Java"]],"start1":20800,"start2":20800,"length1":25,"length2":24},{"diffs":[[0,"ails.\n//"],[-1,"\t"],[0,"\n//\tTo r"]],"start1":21072,"start2":21072,"length1":17,"length2":16},{"diffs":[[0,"enses/>."],[-1,"\t"],[0,"\n\n//\t th"]],"start1":21172,"start2":21172,"length1":17,"length2":16},{"diffs":[[0,"low Copy"],[-1," "],[0,""],[1,""],[0,"\n\tfuncti"]],"start1":21459,"start2":21459,"length1":17,"length2":16},{"diffs":[[0,"value) {"],[-1," "],[0,""],[1,""],[0,"\n//\t\t\t\t "]],"start1":21674,"start2":21674,"length1":17,"length2":16},{"diffs":[[0,"rototype"],[-1," "],[0,"\n//\t\t\t\t "]],"start1":21966,"start2":21966,"length1":17,"length2":16},{"diffs":[[0," have to"],[-1," "],[0,"\n//\t\t\t\t "]],"start1":22131,"start2":22131,"length1":17,"length2":16},{"diffs":[[0,"ject ) {"],[-1," "],[0,"\n\t\t\t\t\tva"]],"start1":22265,"start2":22265,"length1":17,"length2":16},{"diffs":[[0,"otype);\n"],[-1,"\t\t\t\t"],[0,""],[1,""],[0,"\n//\t\t\t\t\t"]],"start1":22316,"start2":22316,"length1":20,"length2":16},{"diffs":[[0,"arget) {"],[-1," "],[0,""],[1,""],[0,"\n\t\t\t\t\t\ti"]],"start1":22503,"start2":22503,"length1":17,"length2":16},{"diffs":[[0,"\n\t\t\t\t\t\t}"],[-1," "],[0,""],[1,""],[0,"\n\t\t\t\t\t}\n"]],"start1":22595,"start2":22595,"length1":17,"length2":16},{"diffs":[[0,";\n\t\t\t\t}\n"],[-1,"\t\t\t\t"],[0,""],[1,""],[0,"\n\t\t\t\tret"]],"start1":22707,"start2":22707,"length1":20,"length2":16},{"diffs":[[0,"h: 256,\n"],[-1,"\t\t\t"],[0,""],[1,""],[0,"\n//\t\t ad"]],"start1":24104,"start2":24104,"length1":19,"length2":16},{"diffs":[[0,"d;\n\t\t},\n"],[-1,"\t\t"],[0,""],[1,""],[0,"\n//\t\t de"]],"start1":24709,"start2":24709,"length1":18,"length2":16},{"diffs":[[0,"rsively."],[-1,"  "],[0,""],[1,""],[0,"\n\t\t\tthis"]],"start1":26902,"start2":26902,"length1":18,"length2":16},{"diffs":[[0,"thers to"],[-1," "],[0,""],[1,""],[0,"\n//\t reg"]],"start1":28003,"start2":28003,"length1":17,"length2":16},{"diffs":[[0,");\n\t\t},\n"],[-1,"        "],[0,""],[1,""],[0,"\n\t\tpopul"]],"start1":30376,"start2":30376,"length1":24,"length2":16},{"diffs":[[0,"\t}\n\t});\n"],[-1,"    "],[0,"\n// Code"]],"start1":30868,"start2":30868,"length1":20,"length2":16}]],"length":31274,"saved":false}
{"ts":1357768737147,"patch":[[{"diffs":[[0,"nction ("],[-1," "],[0,") {\n\tglo"]],"start1":607,"start2":607,"length1":17,"length2":16}]],"length":31273,"saved":false}
{"ts":1357772285832,"patch":[[{"diffs":[[0,"/\n\n("],[-1," function () {\n\tglobal = ( typeof window == 'object') ? window : ( typeof global == 'object') ? global : { dev: null };\n\tconsole = console || {};\n\tconsole.log = console.log || function () {};\n    var fs, path, ast, ugg, http;\n\tif ( typeof require === 'function' ) {\n\t\tfs = require( 'fs' );\n\t\tpath = require('path');\n\t\tast = require('uglify-js').parser;\n\t\tugg = require('uglify-js').uglify;\n\t\thttp = require( 'http' );\n\t}\n\tvar _ = {\n\t\tdebugging : 0,\n\t\tapplication : {},\n\t\tutil : {\n\t\t\tstringify: function ( obj, done ){\n                if( typeof obj === 'undefined'){\n                    return '{undefined}';\n                }\n\t\t\t\tif ( obj === null ){\n\t\t\t\t\treturn '{null}';\n\t\t\t\t}\n\t\t\t\tif ( obj.tagName){\n\t\t\t\t\treturn '<' + obj.tagName + '>';\n\t\t\t\t}\n//\t\t\t\tif (obj._className){\n//\t\t\t\t\treturn obj.toString();\n//\t\t\t\t}\n                var s = '', val;\n                if (obj instanceof Array){\n                    s += '[ ';\n\t\t\t\t\tfor (var i = 0; i < obj.length; i++ ){\n\t\t\t\t\t\tval = obj[i];\n\t\t\t\t\t\tval = _.util.stringify( val, true );\n\t\t\t\t\t\ts+=  val + ',' ;\n\t\t\t\t\t}\n\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\ts+=' ]';\n\t\t\t\t\treturn s;\n                }\n\t\t\t\tswitch( typeof obj ){\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\ts += '{ ';\n\t\t\t\t\t\tfor (var key in obj ){\n\t\t\t\t\t\t\tval = obj[key];\n\t\t\t\t\t\t\tvar type = typeof val;\n\t\t\t\t\t\t\tif(done){\n\t\t\t\t\t\t\t\tval = ( type === '{object}' || type === '{function}' ) ? type : val;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tval = _.util.stringify(val, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts+= ' ' + key + ' : ' + val + ',' ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\t\ts+=' }';\n\t\t\t\t\t\treturn s\n\t\t\t\t\tcase 'function':\n\t\t\t\t\t\treturn '{function}';\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeepCopy : deepCopy,\n\t\t\tscope : function ( fn, scope, functionName ) {\n\t\t\t\treturn function () {\n                    return fn.apply( scope, arguments );\n                };//closure\n\t\t\t},//scope\n\t\t\tisMethod : function( property ) {\n\t\t\t\treturn ( ( typeof property === 'function' ) && ( ! ( property instanceof RegExp ) ) );\n\t\t\t}//isMethod\n\t\t},// util\n\t\tloader : {\n\t\t\tqueue : [],\n\t\t\t_import : function( classPath ) {//--------------------------------------------------------------- loader._import (load)\n\t\t\t\tif( _.loader.queue.indexOf( classPath ) < 0 ) {\n\t\t\t\t\t_.loader.load( classPath );// push path into loading queue\n\t\t\t\t}// if\n\t\t\t},// _import\n\t\t\t_class : function ( className ) {//--------------------------------------------------------------- loader._class (stub)\n_verbose( 'creating stub class for', className );\n\t\t\t\tvar stub = {\n\t\t\t\t\t_extends : function( superName ) {\n_verbose( 'which extends', superName)\n\t\t\t\t\t\tthis._super = superName;//set super name for definition tree\n\t\t\t\t\t}// _extends\n\t\t\t\t};// stub\n\t\t\t\tglobal[ className ] = stub;\n\t\t\t\treturn global[ className ];\n\t\t\t},// _class\n\t\t\tload : function( classPath ) {\n\t\t\t\tvar code, scriptPath;\n//TODO: http classPaths\n\t\t\t\tvar binPath = 'bin/' + classPath;\n\t\t\t\tscriptPath = 'src/' + classPath.replace( /\\./g, '/' ) + '.js';\n\t\t\t\ttry{\n\t\t\t\t\tthis.queue.push( classPath);\n\t\t\t\t\tif( fs && path && ast && ugg ){//server\n\t\t\t\t\t\ttry{\n_verbose( 'looking for bytecode in', binPath );\n\t\t\t\t\t\t\tcode = fs.readFileSync( binPath );\n\t\t\t\t\t\t}catch( e ){\n_verbose( 'no bytecode available.');\n\t\t\t\t\t\t\ttry{\n_verbose( 'loading source code from', scriptPath );\n\t\t\t\t\t\t\t\tcode = fs.readFileSync( scriptPath, 'ascii' );\n\t\t\t\t\t\t\t\ttry{\n_verbose( 'generating bytecode for', classPath, 'source bytes =', code.length );\n\t\t\t\t\t\t\t\t\tif(! _.debugging ){\n\t\t\t\t\t\t\t\t\t\tcode = ast.parse( code ); // parse code and get the initial AST\n\t\t\t\t\t\t\t\t\t\tif(classPath == 'Code'){\n\t\t\t\t\t\t\t\t\t\t\tcode = ugg.ast_mangle( code ); // get a new AST with mangled names\n_verbose( 'mangling', classPath );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcode = ugg.ast_squeeze( code ); // get an AST with compression optimizations\n_verbose( 'squeezing', classPath );\n\t\t\t\t\t\t\t\t\t\tcode = ugg.gen_code( code ); // compressed code here\n\n                                        code = ( code.substr( 0, -1 ) === ';' ) ? code : ( code + ';' );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(! path.existsSync( 'bin/' ) ){\n_info( 'creating bin' );\n\t\t\t\t\t\t\t\t\t\tfs.mkdirSync( 'bin/');\n\t\t\t\t\t\t\t\t\t}\n_verbose( 'writing bytecode to', binPath, 'final bytes =', code.length );\n\t\t\t\t\t\t\t\t\tfs.writeFileSync( binPath, code );\n\t\t\t\t\t\t\t\t}catch (error ){\n\t\t\t\t\t\t\t\t\tthrow new Error( error );\n_verbose( 'error creating bytecode' );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}catch( error ){\n_error( 'file system error');\n\t\t\t\t\t\t\t\tthrow new Error( error );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {//client // ( typeof XMLHttpRequest == \"function\" )\n_verbose( 'streaming source code from', scriptURL );\n\t\t\t\t\t\tvar scriptURL = scriptPath;\n\t\t\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\t\t\trequest.open( 'GET', scriptURL, false );\n\t\t\t\t\t\trequest.send( null );\n\t\t\t\t\t\tif ( request.status == 200 ) {\n\t\t\t\t\t\t\tcode = request.responseText;\n\t\t\t\t\t\t} else {// else if\n_error( 'XMLHttpRequest error');\n\t\t\t\t\t\t    throw new Error( request.status );\n\t\t\t\t\t\t};// else\n\t\t\t\t\t}\n\t\t\t\t}catch( error ){\n_error( 'error loading', classPath, ':', error.message ) ;\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n_verbose( 'loaded', classPath, '. processing imports' );\n\t\t\t\ttry{\n\t\t\t\t\tglobal._import = this._import;//load\n\t\t\t\t\tglobal._class = this._class;//stub\n\t\t\t\t\tcode = code.toString();\n\t\t\t\t\tif(code.indexOf('_import') > -1 || code.indexOf('_class') > -1){\n\t\t\t\t\t\teval( code );\n\t\t\t\t\t}\n\t\t\t\t}catch( error ){\n_error( 'error completing imports for '+  classPath + '. Error Text:' + error.message );\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\tvar className = classPath.split( '.' ).pop();\n\t\t\t\tglobal[ className ] = global[ className ] || {};\n\t\t\t\tglobal[ className ]._script = code;//store script\n\t\t\t\t_.compiler.queue.push(className );// add script to compilation queue\n\t\t\t\tif( this.queue.length == _.compiler.queue.length ){\n\t\t\t\t\t_.compiler.compileClasses();\n\t\t\t\t\tthis.queue = [];\n\t\t\t\t}// if\n\t\t\t}//, load\n\t\t},// loader\n\t\tcompiler : {\n\t\t\tbuffer :'',\n\t\t\tqueue : [],\n\t\t\t_import : function( classPath ) {\n\t\t\t\tvar className = classPath.split( '.' ).pop();\n\t\t\t\t_.compiler.compile( className );\n\t\t\t},// _import\n\t\t\t_class : function( className ) {\n_verbose( 'skipping _class' );\n\t\t\t\treturn {_extends:function (){}}\n\t\t\t},// _import\n\t\t\tcompileClasses : function () {\n_verbose( 'compiling classes' );\n\t\t\t\tvar className;\n                while ( className = this.queue[ 0 ] ) {\n\t\t\t\t\tthis.compile( className );\n\t\t\t\t}// while\n                _.interpreter.defineClasses();\n                this._queue = [];\n\t\t\t},// compileClasses\n\t\t\tcompile : function ( className ) {\n\t\t\t\tvar index = this.queue.indexOf( className );\n\t\t\t\tif ( index >= 0 ) {\n\t\t\t\t\tthis.queue.splice( index, 1 );\n\t\t\t\t\tvar classObject = global [ className ];\n_verbose( 'adding class', className );\n\t\t\t\t\tglobal._import = this._import;\n\t\t\t\t\tglobal._class = this._class;\n\t\t\t\t\tif( classObject._script.indexOf ('_class') > -1 || classObject._script.indexOf('_import') > -1 ){\n\t\t\t\t\t\teval( classObject._script );\n\t\t\t\t\t}\n\t\t\t\t\tthis.buffer = this.buffer.concat( classObject._script );\n_verbose( this.buffer.length, 'bytes', this.queue.length, 'scripts remain.' );\n\t\t\t\t}// if\n\t\t\t}//compile\n\t\t},// compiler\n\t\tinterpreter : {\n\t\t\tinitializing : false,\n\t\t\t_import : function ( classPath ) {//--------------------------------------------------------------- interpreter._import (null)\n_verbose( 'skipping import: ', classPath );\n\t\t\t},// _import\n\t\t\t_class : function( className, properties ) {//--------------------------------------------------------------- interpreter._class define\n_verbose( '_class', className );\n\t\t\t\tif( global[ className ] &&  global[ className ]._constructor ) {// if class is stub\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tvar newClass = Class._plus( className, properties );// create the class from Class object\n\t\t\t\t\tnewClass._extends = function( parentClassName, properties ) {\n_verbose( '_extends', parentClassName );\n\t\t\t\t\t\t\tglobal[ className ] = global[ parentClassName ]._plus( className, properties );\n\t\t\t\t\t\t \tglobal[ className ]._className = className;\n\t\t\t\t\t}// _extends\n\t\t\t\t\tglobal[ className ] = newClass;\n\t\t\t\t} //if\n\t\t\t\t_.interpreter.applicationName = className;\n\t\t\t\treturn global[ className ]\n\t\t\t },// _class\n\t\t\tdefineClasses : function () {\n_verbose( 'defining classes' );\n\t\t\t\tglobal._import = this._import; // null\n\t\t\t\tglobal._class = this._class; // define / extend class\n\t\t\t\teval( _.compiler.buffer );\n\t\t\t\t_.compiler.buffer = '';\n\t\t\t\tCode.x();\n\t\t\t}//defineClasses\n\t\t}// interpreter\n\t};// _\nglobal.DebugLevels = {\n        SILENT  : 0,\n        ERRORS  : 1,\n        WARNINGS: 2,\n        DEBUG   : 3,\n        INFO    : 4,\n        VERBOSE : 5\n\t};\n\t_trace = function () {\n\t\tvar output = \"\";\n\t\tvar args = arguments;\n\t\tfor( index in args ) {\n\t\t\tvar token = _.util.stringify(args[ index ]);\n\t\t\toutput += token + ( ' ' );\n\t\t}// for\n\t\tconsole.log( output );\n\t};// _trace\n\n    _error = function () {\n\t\tif( _.debugging >= DebugLevels.ERRORS ) _trace.apply( this, arguments );\n\t};//\n    _warn = function () {\n\t\tif( _.debugging >= DebugLevels.WARNINGS ) _trace.apply( this, arguments );\n\t};//\n    _info = function () {\n\t\tif( _.debugging >= DebugLevels.INFO ) _trace.apply( this, arguments );\n\t};//\n    _debug = function () {\n    \tif( _.debugging >= DebugLevels.DEBUG ) _trace.apply( this, arguments );\n\t};//\n    _verbose = function () {\n    \tif( _.debugging >= DebugLevels.VERBOSE ) _trace.apply( this, arguments );\n\t};//\n\n\t_package = function() { // Future Use\n_verbose( 'package', arguments[ 0 ] );\n\t};// _package\n\n\n\t// DON'T GET CUTE.\n\n\n\t/*\n\t *\n\t * Class is a modification of 'Class'\n\t * originally by the immortal John Resig\n\t *\n\t * http://bit.ly/4U5H\n\t *\n\t *\n\t */\n//\t   var fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n\t  // The base Class implementation --\n\t  // provides _get and _set shortcuts to eliminate abiguous assignment ( is it a property or a getterSetter ? )\n\t  // provides .add() to replace +=\n\t  var Class = function(){};\n\t  Class._className = 'Class';\n\t  Class.prototype = {\n\t\t\t_get : function( propertyName ){\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\treturn ( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]() : this[ propertyName ];\n\t\t\t},\n\t\t\t_set : function( propertyName, value ){\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\tthis[propertyName] = value;\n\t\t\t\t}else{\n\t\t\t\t\t( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]( value ) : this[ propertyName ] = value;\n\t\t\t\t}\n\n\t\t\t},\n\t\t\t_add : function( value, propertyName ){\n\t\t\t\tvalue = value || 1;\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\tthis[propertyName] = value;\n\t\t\t\t}else{\n\t\t\t\t\t( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]( this[ propertyName ]() + value ) : this[ propertyName ] += value;\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString : function () { return '['+this._className+']'; }\n\t\t};\n\n\t  // Create a new Class that inherits from this class\n\tClass._plus = function(className, additions) {\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the __init__ constructor)\n\t\t_.interpreter.initializing = true;\n\t\tvar newPrototype = new this();\n\t\t_.interpreter.initializing = false;\n\t\tnewPrototype._className = className;\n\t\tvar superPrototype =  this.prototype;\n\n\t\tnewPrototype._ = superPrototype._ ? _.util.deepCopy( superPrototype._ ) : {}; // private space\n\t\tnewPrototype.__ = superPrototype.__ ? _.util.deepCopy( superPrototype.__ ) : { getters : {}, setters: {}, getSetterNames:[] }; // getters/setters space\n\n\t\t// TODO: getter/setters proper\n\n\t\tfor (var name in additions) {\n\t\t\tvar addition = additions[ name ];\n\t\t\tvar\tpropertyKeyword;\n\t\t\tvar\tpropertyType;\n\t\t\tvar propertyName = name;\n\t\t\tvar propertyDefault = '[function]';\n\t\t\tvar attachTarget = {};\n\n\t\t// TODO: getter/setters proper ?\n\n\t\t\tif ( name.indexOf( 'private_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'private';\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tattachTarget = newPrototype._;\n\t\t\t} else if ( name.indexOf( 'static_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'static';\n\t\t\t\tattachTarget = ClassObject;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t}  else if ( name.indexOf( 'get_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'get';\n\t\t\t\tattachTarget = newPrototype.__.getters;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tif( newPrototype.__.getSetterNames.indexOf( propertyName ) == -1 ){\n\t\t\t\t\tnewPrototype.__.getSetterNames.push( propertyName );\n\t\t\t\t}\n\t\t\t}  else if ( name.indexOf( 'set_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'set';\n\t\t\t\tattachTarget = newPrototype.__.setters;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tif( newPrototype.__.getSetterNames.indexOf( propertyName ) == -1 ){\n\t\t\t\t\tnewPrototype.__.getSetterNames.push( propertyName );\n\t\t\t\t}\n\t\t\t} else if ( name === className ){\n\t\t\t\tpropertyKeyword = 'constructor';\n\t\t\t\tattachTarget = newPrototype;\n\t\t\t\tpropertyName = '__init__';\n\t\t\t} else {\n\t\t\t\tpropertyKeyword = 'public';\n\t\t\t\tattachTarget = newPrototype;\n\t\t\t}\n\t\t\tvar property;\n\t\t\tif ( typeof addition == 'function'  ) {\n                propertyType = 'function';\n                property = ( function( propertyName, fn, _super ){\n                return function() {\n                    var args = '';\n                    for(var i in arguments){\n                        args += _.util.stringify( arguments[ i ])+',';\n                    }\n                    args = args.slice(0, -1);\n_verbose( className+'.'+propertyName+'( '+args+' )' );\n\t\t\t            var tmp = this._super;\n\t\t\t            // Allow this._super() to call superconstructor, and allow this._super().*() to call the super method\n\t\t\t\t        this._super = function(){\n\t\t\t            \tif( propertyName === '__init__' ) {\n\t\t\t\t\t\t\t\tvar __init__ = _super.__init__ || function(){};\n\t\t\t\t\t\t\t\t_super = _super._superPrototype;\n\t\t            \t\t\treturn __init__.apply( this, arguments)\n\t\t\t\t            }else{\n\t\t\t\t            \tvar names = [];\n\t\t\t\t            \tvar sup = {};\n\t\t\t\t            \tfor( var memberName in _super ){\n\t\t\t\t            \t\tvar member = _super[ memberName ]\n\t\t\t\t            \t\tif( typeof member === 'function' ){\n\t\t\t\t            \t\t\tsup[ memberName ] = _.util.scope( member, this, memberName );\n\t\t\t\t\t            \t\tnames.push(memberName)\n\t\t\t\t            \t\t}\n\t\t\t\t            \t}\n\t\t\t\t            \t_super = _super._superPrototype;\n\t\t\t\t            \treturn sup\n\t\t\t\t            }\n\t\t\t            }\n\t\t\t            // The __init__ method only need to be bound temporarily, so we\n\t\t\t            // remove it when we're done executing\n\t\t\t            var ret = fn.apply( this, arguments );\n\t\t\t            this._super = tmp;\n\t\t\t            _super = superPrototype;\n\t\t\t            return ret;\n\t\t\t\t    };\n\t\t        })( propertyName, addition, superPrototype );\n\t\t\t}else{\n\t\t\t\tpropertyType = 'var';\n\t\t\t\tpropertyDefault = addition;\n\t\t    \tproperty = _.util.deepCopy( addition );\n\t\t    }\n\t\t\tattachTarget[ propertyName ] = property;\n_verbose('\\t', propertyKeyword, propertyType, propertyName, '=', propertyDefault );\n\t\t}\n\n\t\t// Create getter / setter properties\n\t\tfor ( var index in newPrototype.__.getSetterNames ){\n\t\t\tvar getSetterName = newPrototype.__.getSetterNames[ index ];\n_verbose( 'property name:', getSetterName);\n\t\t\tvar getter = newPrototype.__.getters[getSetterName ];\n_verbose( 'getter function:', getter) ;\n\t\t\tvar setter = newPrototype.__.setters[getSetterName ];\n_verbose( 'setter function:', setter );\n\t\t\tnewPrototype[ getSetterName ] = ( function( getter, setter, getSetterName ){\n\t\t\t\treturn function ( value ) {\n\t\t\t\t\tif( value === undefined ) {\n\t\t\t\t\t\tif( getter ) {\n_verbose( 'getting', getSetterName, 'of', this, ':', getter());\n\t\t\t\t\t\t\treturn getter.call( this );\n\t\t\t\t\t\t}else return;\n\t\t\t\t\t}\n\t\t\t\t\tif( setter ){\n_verbose( 'setting', getSetterName, 'of', this, 'to', value);\n\t\t\t\t\t\tsetter.call( this, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})( getter, setter, getSetterName );\n\t\t};\n\t\t// The dummy class constructor (scoping)\n\t\tfunction ClassObject() {\n\t\t  // All construction is actually done in the __init__ method (declared using the new Class name as string ( _className ) )\n\t\t\tthis._ = _.util.deepCopy( this._ );\n\t\t\tthis.__ = _.util.deepCopy( this.__ );\n\t\t\tif ( !_.interpreter.initializing ){\n_verbose( 'new', this._className );\n\t\t\t\tif ( this._className.indexOf( 'Event' ) < 0 && [ 'Dictionary' ].indexOf( this._className ) < 0 ) {\n\n\t\t\t\t};\n\t\t\t\tfor ( var propertyName in this ){\n\t\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\t\tif ( _.util.isMethod( property ) && [ 'toString', '_get', '_set', '_add' ].indexOf( propertyName) < 0 ){\n_verbose( 'scoping public', propertyName )\n\t\t\t\t\t\tthis[ propertyName ] = _.util.scope( property, this, propertyName );\n\t\t\t\t\t};//if\n\t\t\t\t};//for\n\n\t\t\t\tfor ( propertyName in this._ ){\n\t\t\t\t\tvar property = this._[ propertyName ];\n\t\t\t\t\tif ( _.util.isMethod( property ) ){\n_verbose( 'scoping private', propertyName )\n\t\t\t\t\t\tthis._[ propertyName ] = _.util.scope( property, this );\n\t\t\t\t\t}//if\n\t\t\t\t}//for\n\t\t\t  \tif( this.__init__ ) {\n\t\t\t \t\tthis.__init__.apply( this, arguments );\n\t\t\t  \t};//if\n\t\t\t}//if\n\t\t}\n\t\t//inheritance chain\n\t\tnewPrototype._superPrototype =  superPrototype;\n\t\t// Populate our constructed prototype object\n\t\tClassObject.prototype = newPrototype;\n\n\t\t// Enforce the constructor to be what we expect\n\t\tClassObject.constructor = ClassObject;\n\n\t\t// And make this class extensible\n\t\tClassObject._plus = arguments.callee;\n\n\t\treturn ClassObject;\n\t};\n\n\tvar Code = function(){\n\t\treturn Code.c('Code');\n\t};\n\tCode.r = function ( applicationClassPath, parameters ) {\n_verbose('Code.r(',applicationClassPath,',', _.util.stringify(parameters), ')');\n\t_.application.parameters = parameters;\n\t_.application.classPath = applicationClassPath;\n\t\tglobal._import = _.loader._import;\n\t\t_import( applicationClassPath );\n\n\t};\n\tCode.x = function ( applicationClassPath, parameters ){\n_verbose('Code.x(',applicationClassPath,',', _.util.stringify(parameters), ')');\n\t\tparameters = parameters || this._.application.parameters;\n\t\tapplicationClassPath = applicationClassPath || this._.application.classPath;\n\t\tvar applicationClassName = applicationClassPath.split( '.' ).pop();\n\t\tnew global[ applicationClassName ](parameters);//no namespace\n\t\t_.application = {};\n\t};\n\tCode.c = function ( applicationClassPath ) {\n_verbose('Code.c(',applicationClassPath,')');\n\t\tvar libPath = 'lib/'+applicationClassPath+'.js';\n\t\tvar buffer;\n\t\tif( fs ) {\n\t\t\ttry{\n\t\t\t\tbuffer = fs.readFileSync( libPath, 'ascii' );\n\t\t\t}catch( e ){\n\t\t\t\t_verbose( 'no library at', libPath);\n\t\t\t}\n\t\t}\n\t\tif( ! buffer ){\n\t\t\tvar interpreter = _.interpreter;\n\t\t\t_.interpreter = {\n\t\t\t\tdefineClasses : function () {\n_verbose( 'bypassing interpreter.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tglobal._import = _.loader._import;\n\t\t\t_import( applicationClassPath );\n\t\t\tbuffer = _.compiler.buffer;\n\t\t\tif( fs && path ){\n\t\t\t\t_verbose (' fs & path');\n\t\t\t\tif(! path.existsSync( 'lib/' ) ){\n\t\t\t\t\t_verbose( 'creating lib folder')\n\t\t\t\t\tfs.mkdirSync( 'lib/');\n\t\t\t\t}\n\n\t\t\t\t\t_verbose( 'saving lib file to', libPath)\n\t\t\t\tfs.writeFileSync( libPath,  buffer)\n\t\t\t}\n\t\t\t_.compiler.buffer = '';\n\t\t\t_.interpreter = interpreter;\n\t\t}\n\t\treturn buffer\n\t};\n\tCode._ = _;\n\tglobal.Code = Code;\n\tglobal._import = _.interpreter._import;\n\tglobal._class = _.interpreter._class;\n_info('Code.js ready. @2013 Neuromantic, LLC. All Rights reserved. Licenced under the MIT license.')\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////// Goin' Deep /////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n//\t DEEP COPY props http://oranlooney.com/deep-copy-javascript/\n//\t   This section is part of OWL JavaScript Utilities.\n//\n//\tOWL JavaScript Utilities is free software: you can redistribute it and/or\n//\tmodify it under the terms of the GNU Lesser General Public License\n//\tas published by the Free Software Foundation, either version 3 of\n//\tthe License, or (at your option) any later version.\n//\n//\tOWL JavaScript Utilities is distributed in the hope that it will be useful,\n//\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n//\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//\tGNU Lesser General Public License for more details.\n//\n//\tTo receive a copy of the GNU Lesser General Public License, see: <http://www.gnu.org/licenses/>.\n\n//\t the re-usable constructor function used by clone().\n\tfunction Clone() {};\n\n//\t clone objects, skip other types.\n\tfunction clone(target) {\n\t\tif ( typeof target == 'object' ) {\n\t\t\tClone.prototype = target;\n\t\t\treturn new Clone();\n\t\t} else {\n\t\t\treturn target;\n\t\t}\n\t}\n\n\n//\t Shallow Copy\n\tfunction copy(target) {\n\t\tif (typeof target !== 'object' ) {\n\t\t\treturn target;  // non-object have value sematics, so target is already a copy.\n\t\t} else {\n\t\t\tvar value = target.valueOf();\n\t\t\tif (target != value) {\n//\t\t\t\t the object is a standard object wrapper for a native type, say String.\n//\t\t\t\t we can make a copy by instantiating a new object around the value.\n\t\t\t\treturn new target.constructor(value);\n\t\t\t} else {\n//\t\t\t\t ok, we have a normal object. If possible, we'll clone the original's prototype\n//\t\t\t\t (not the original) to get an empty object with the same prototype chain as\n//\t\t\t\t the original.  If just copy the instance properties.  Otherwise, we have to\n//\t\t\t\t copy the whole thing, property-by-property.\n\t\t\t\tif ( target instanceof target.constructor && target.constructor !== Object ) {\n\t\t\t\t\tvar c = clone(target.constructor.prototype);\n\n//\t\t\t\t\t give the copy all the instance properties of target.  It has the same\n//\t\t\t\t\t prototype as target, so inherited properties are already there.\n\t\t\t\t\tfor ( var property in target) {\n\t\t\t\t\t\tif (target.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tc[property] = target[property];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar c = {};\n\t\t\t\t\tfor ( var property in target ) c[property] = target[property];\n\t\t\t\t}\n\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t}\n\n//\t Deep Copy\n\tvar deepCopiers = [];\n\n\tfunction DeepCopier(config) {\n\t\tfor ( var key in config ) this[key] = config[key];\n\t}\n\tDeepCopier.prototype = {\n\t\tconstructor: DeepCopier,\n\n//\t\t determines if this DeepCopier can handle the given object.\n\t\tcanCopy: function(source) { return false; },\n\n//\t\t starts the deep copying process by creating the copy object.  You\n//\t\t can initialize any properties you want, but you can't call recursively\n//\t\t into the DeeopCopyAlgorithm.\n\t\tcreate: function(source) { },\n\n//\t\t Completes the deep copy of the source object by populating any properties\n//\t\t that need to be recursively deep copied.  You can do this by using the\n//\t\t provided deepCopyAlgorithm instance's deepCopy() method.  This will handle\n//\t\t cyclic references for objects already deepCopied, including the source object\n//\t\t itself.  The \"result\" passed in is the object returned from create().\n\t\tpopulate: function(deepCopyAlgorithm, source, result) {}\n\t};\n\n\tfunction DeepCopyAlgorithm() {\n//\t\t copiedObjects keeps track of objects already copied by this\n//\t\t deepCopy operation, so we can correctly handle cyclic references.\n\t\tthis.copiedObjects = [];\n\t\tthisPass = this;\n\t\tthis.recursiveDeepCopy = function(source) {\n\t\t\treturn thisPass.deepCopy(source);\n\t\t}\n\t\tthis.depth = 0;\n\t}\n\tDeepCopyAlgorithm.prototype = {\n\t\tconstructor: DeepCopyAlgorithm,\n\n\t\tmaxDepth: 256,\n\n//\t\t add an object to the cache.  No attempt is made to filter duplicates;\n//\t\t we always check getCachedResult() before calling it.\n\t\tcacheResult: function(source, result) {\n\t\t\tthis.copiedObjects.push([source, result]);\n\t\t},\n\n//\t\t Returns the cached copy of a given object, or undefined if it's an\n//\t\t object we haven't seen before.\n\t\tgetCachedResult: function(source) {\n\t\t\tvar copiedObjects = this.copiedObjects;\n\t\t\tvar length = copiedObjects.length;\n\t\t\tfor ( var i=0; i<length; i++ ) {\n\t\t\t\tif ( copiedObjects[i][0] === source ) {\n\t\t\t\t\treturn copiedObjects[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\n//\t\t deepCopy handles the simple cases itself: non-objects and object's we've seen before.\n//\t\t For complex cases, it first identifies an appropriate DeepCopier, then calls\n//\t\t applyDeepCopier() to delegate the details of copying the object to that DeepCopier.\n\t\tdeepCopy: function(source) {\n//\t\t\t null is a special case: it's the only value of type 'object' without properties.\n\t\t\tif ( source === null ) return null;\n\n//\t\t\t All non-objects use value semantics and don't need explict copying.\n\t\t\tif ( typeof source !== 'object' ) return source;\n\n\t\t\tvar cachedResult = this.getCachedResult(source);\n\n//\t\t\t we've already seen this object during this deep copy operation\n//\t\t\t so can immediately return the result.  This preserves the cyclic\n//\t\t\t reference structure and protects us from infinite recursion.\n\t\t\tif ( cachedResult ) return cachedResult;\n\n//\t\t\t objects may need special handling depending on their class.  There is\n//\t\t\t a class of handlers call \"DeepCopiers\"  that know how to copy certain\n//\t\t\t objects.  There is also a final, generic deep copier that can handle any object.\n\t\t\tfor ( var i=0; i<deepCopiers.length; i++ ) {\n\t\t\t\tvar deepCopier = deepCopiers[i];\n\t\t\t\tif ( deepCopier.canCopy(source) ) {\n\t\t\t\t\treturn this.applyDeepCopier(deepCopier, source);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// the generic copier can handle anything, so we should never reach this line.\n\t\t\tthrow new Error(\"no DeepCopier is able to copy \" + source);\n\t\t},\n\n//\t\t once we've identified which DeepCopier to use, we need to call it in a very\n//\t\t particular order: create, cache, populate.  This is the key to detecting cycles.\n//\t\t We also keep track of recursion depth when calling the potentially recursive\n//\t\t populate(): this is a fail-fast to prevent an infinite loop from consuming all\n//\t\t available memory and crashing or slowing down the browser.\n\t\tapplyDeepCopier: function(deepCopier, source) {\n//\t\t\t Start by creating a stub object that represents the copy.\n\t\t\tvar result = deepCopier.create(source);\n\n//\t\t\t we now know the deep copy of source should always be result, so if we encounter\n//\t\t\t source again during this deep copy we can immediately use result instead of\n//\t\t\t descending into it recursively.\n\t\t\tthis.cacheResult(source, result);\n\n//\t\t\t only DeepCopier::populate() can recursively deep copy.  So, to keep track\n//\t\t\t of recursion depth, we increment this shared counter before calling it,\n//\t\t\t and decrement it afterwards.\n\t\t\tthis.depth++;\n\t\t\tif ( this.depth > this.maxDepth ) {\n\t\t\t\tthrow new Error(\"Exceeded max recursion depth in deep copy.\");\n\t\t\t}\n\n//\t\t\t It's now safe to let the deepCopier recursively deep copy its properties.\n\t\t\tdeepCopier.populate(this.recursiveDeepCopy, source, result);\n\n\t\t\tthis.depth--;\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n//\t entry point for deep copy.\n//\t   source is the object to be deep copied.\n//\t   maxDepth is an optional recursion limit. Defaults to 256.\n\tfunction deepCopy(source, maxDepth) {\n\t\tvar deepCopyAlgorithm = new DeepCopyAlgorithm();\n\t\tif ( maxDepth ) deepCopyAlgorithm.maxDepth = maxDepth;\n\t\treturn deepCopyAlgorithm.deepCopy(source);\n\t}\n\n//\t publicly expose the DeepCopier class.\n\tdeepCopy.DeepCopier = DeepCopier;\n\n//\t publicly expose the list of deepCopiers.\n\tdeepCopy.deepCopiers = deepCopiers;\n\n//\t make deepCopy() extensible by allowing others to\n//\t register their own custom DeepCopiers.\n\tdeepCopy.register = function(deepCopier) {\n\t\tif ( !(deepCopier instanceof DeepCopier) ) {\n\t\t\tdeepCopier = new DeepCopier(deepCopier);\n\t\t}\n\t\tdeepCopiers.unshift(deepCopier);\n\t}\n\n//\t Generic Object copier\n//\t the ultimate fallback DeepCopier, which tries to handle the generic case.  This\n//\t should work for base Objects and many user-defined classes.\n\tdeepCopy.register({\n\t\tcanCopy: function(source) { return true; },\n\n\t\tcreate: function(source) {\n\t\t\tif ( source instanceof source.constructor ) {\n\t\t\t\treturn clone(source.constructor.prototype);\n\t\t\t} else {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var key in source ) {\n\t\t\t\tif ( source.hasOwnProperty(key) ) {\n\t\t\t\t\tresult[key] = deepCopy(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t});\n\n//\t Array copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) {\n\t\t\treturn ( source instanceof Array );\n\t\t},\n\n\t\tcreate: function(source) {\n\t\t\treturn new source.constructor();\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var i=0; i<source.length; i++) {\n\t\t\t\tresult.push( deepCopy(source[i]) );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t});\n\n//\t Date copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) {\n\t\t\treturn ( source instanceof Date );\n\t\t},\n\n\t\tcreate: function(source) {\n\t\t\treturn new Date(source);\n\t\t}\n\t});\n\n//\t HTML DOM Node\n\n//\t utility function to detect Nodes.  In particular, we're looking\n//\t for the cloneNode method.  The global document is also defined to\n//\t be a Node, but is a special case in many ways.\n\tfunction isNode(source) {\n\t\tif ( global.Node ) {\n\t\t\treturn source instanceof Node;\n\t\t} else {\n\t\t\t// the document is a special Node and doesn't have many of\n\t\t\t// the common properties so we use an identity check instead.\n\t\t\tif ( typeof document == 'object' && source === document ) return true;\n\t\t\treturn (\n\t\t\t\ttypeof source.nodeType === 'number' &&\n\t\t\t\tsource.attributes &&\n\t\t\t\tsource.childNodes &&\n\t\t\t\tsource.cloneNode\n\t\t\t);\n\t\t}\n\t}\n\n//\t Node copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) { return isNode(source); },\n\n\t\tcreate: function(source) {\n//\t\t\t there can only be one (document).\n\t\t\tif (typeof document == 'object' && source === document ) return document;\n//\t\t\t start with a shallow copy.  We'll handle the deep copy of\n//\t\t\t its children ourselves.\n\t\t\treturn source.cloneNode(false);\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n//\t\t\t we're not copying the global document, so don't have to populate it either.\n\t\t\tif ( typeof document == 'object' && source === document ) return document;\n//\t\t\t if this Node has children, deep copy them one-by-one.\n\t\t\tif ( source.childNodes && source.childNodes.length ) {\n\t\t\t\tfor ( var i=0; i<source.childNodes.length; i++ ) {\n\t\t\t\t\tvar childCopy = deepCopy(source.childNodes[i]);\n\t\t\t\t\tresult.appendChild(childCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n// Code.js : Fase Dictionary\n\tdeepCopy.register( {\n\t\tcanCopy: function(source) { return source._className == 'Dictionary'; },\n\t\tcreate: function() {\n\t\t\treturn new Dictionary();\n\t\t},\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var i in source._keys ){\n\t\t\t\tresult._keys[ i ] = source._keys[ i ];\n\t\t\t\tresult._values[ i ] = deepCopy( source.values[ i ])\n\t\t\t};\n\t\t}\n\t});\n"],[1,"function() {\n    global = (typeof window == 'object') ? window : (typeof global == 'object') ? global : {\n        dev: null\n    };\n    console = console || {};\n    console.log = console.log || function() {};\n    var fs, path, ast, ugg, http;\n    if (typeof require === 'function') {\n        fs = require('fs');\n        path = require('path');\n        ast = require('uglify-js').parser;\n        ugg = require('uglify-js').uglify;\n        http = require('http');\n    }\n    var _ = {\n        debugging: 0,\n        application: {},\n        util: {\n            stringify: function(obj, done) {\n                if (typeof obj === 'undefined') {\n                    return '{undefined}';\n                }\n                if (obj === null) {\n                    return '{null}';\n                }\n                if (obj.tagName) {\n                    return '<' + obj.tagName + '>';\n                }\n                //\t\t\t\tif (obj._className){\n                //\t\t\t\t\treturn obj.toString();\n                //\t\t\t\t}\n                var s = '',\n                    val;\n                if (obj instanceof Array) {\n                    s += '[ ';\n                    for (var i = 0; i < obj.length; i++) {\n                        val = obj[i];\n                        val = _.util.stringify(val, true);\n                        s += val + ',';\n                    }\n                    s = s.slice(0, - 1);\n                    s += ' ]';\n                    return s;\n                }\n                switch (typeof obj) {\n                case 'object':\n                    s += '{ ';\n                    for (var key in obj) {\n                        val = obj[key];\n                        var type = typeof val;\n                        if (done) {\n                            val = (type === '{object}' || type === '{function}') ? type : val;\n                        }\n                        else {\n                            val = _.util.stringify(val, true);\n                        }\n                        s += ' ' + key + ' : ' + val + ',';\n                    }\n                    s = s.slice(0, - 1);\n                    s += ' }';\n                    return s\n                case 'function':\n                    return '{function}';\n                default:\n                    return obj;\n                }\n            },\n            deepCopy: deepCopy,\n            scope: function(fn, scope, functionName) {\n                return function() {\n                    return fn.apply(scope, arguments);\n                }; //closure\n            }, //scope\n            isMethod: function(property) {\n                return ((typeof property === 'function') && (!(property instanceof RegExp)));\n            } //isMethod\n        }, // util\n        loader: {\n            queue: [],\n            _import: function(classPath) { //--------------------------------------------------------------- loader._import (load)\n                if (_.loader.queue.indexOf(classPath) < 0) {\n                    _.loader.load(classPath); // push path into loading queue\n                } // if\n            }, // _import\n            _class: function(className) { //--------------------------------------------------------------- loader._class (stub)\n                _verbose('creating stub class for', className);\n                var stub = {\n                    _extends: function(superName) {\n_verbose('which extends', superName)\n                        this._super = superName; //set super name for definition tree\n                    } // _extends\n                }; // stub\n                global[className] = stub;\n                return global[className];\n            }, // _class\n            load: function(classPath) {\n                var code, scriptPath;\n                //TODO: http classPaths\n                var binPath = 'bin/' + classPath;\n                scriptPath = 'src/' + classPath.replace(/\\./g, '/') + '.js';\n                try {\n                    this.queue.push(classPath);\n                    if (fs && path && ast && ugg) { //server\n                        try {\n_verbose('looking for bytecode in', binPath);\n                            code = fs.readFileSync(binPath);\n                        }\n                        catch (e) {\n_verbose('no bytecode available.');\n                            try {\n_verbose('loading source code from', scriptPath);\n                                code = fs.readFileSync(scriptPath, 'ascii');\n                                try {\n_verbose('generating bytecode for', classPath, 'source bytes =', code.length);\n                                    if (!_.debugging) {\n                                        code = ast.parse(code); // parse code and get the initial AST\n                                        if (classPath == 'Code') {\n                                            code = ugg.ast_mangle(code); // get a new AST with mangled names\n_verbose('mangling', classPath);\n                                        }\n                                        code = ugg.ast_squeeze(code); // get an AST with compression optimizations\n_verbose('squeezing', classPath);\n                                        code = ugg.gen_code(code); // compressed code here\n\n                                        code = (code.substr(0, - 1) === ';') ? code : (code + ';');\n                                    }\n                                    if (!path.existsSync('bin/')) {\n                                        _info('creating bin');\n                                        fs.mkdirSync('bin/');\n                                    }\n_verbose('writing bytecode to', binPath, 'final bytes =', code.length);\n                                    fs.writeFileSync(binPath, code);\n                                }\n                                catch (error) {\n                                    throw new Error(error);\n_verbose('error creating bytecode');\n                                }\n                            }\n                            catch (error) {\n_error('file system error');\n                                throw new Error(error);\n                            }\n                        }\n                    }\n                    else { //client // ( typeof XMLHttpRequest == \"function\" )\n_verbose('streaming source code from', scriptURL);\n                        var scriptURL = scriptPath;\n                        var request = new XMLHttpRequest();\n                        request.open('GET', scriptURL, false);\n                        request.send(null);\n                        if (request.status == 200) {\n                            code = request.responseText;\n                        }\n                        else { // else if\n_error('XMLHttpRequest error');\n                            throw new Error(request.status);\n                        } // else\n                    }\n                }\n                catch (error) {\n_error('error loading', classPath, ':', error.message);\n                    throw error;\n                }\n_verbose('loaded', classPath, '. processing imports');\n                try {\n                    global._import = this._import; //load\n                    global._class = this._class; //stub\n                    code = code.toString();\n                    if (code.indexOf('_import') > -1 || code.indexOf('_class') > -1) {\n                        eval(code);\n                    }\n                }\n                catch (error) {\n_error('error completing imports for ' + classPath + '. Error Text:' + error.message);\n                    throw error;\n                }\n                var className = classPath.split('.').pop();\n                global[className] = global[className] || {};\n                global[className]._script = code; //store script\n                _.compiler.queue.push(className); // add script to compilation queue\n                if (this.queue.length == _.compiler.queue.length) {\n                    _.compiler.compileClasses();\n                    this.queue = [];\n                } // if\n            } //, load\n        }, // loader\n        compiler: {\n            buffer: '',\n            queue: [],\n            _import: function(classPath) {\n                var className = classPath.split('.').pop();\n                _.compiler.compile(className);\n            }, // _import\n            _class: function(className) {\n_verbose('skipping _class');\n                return {\n                    _extends: function() {}\n                }\n            }, // _import\n            compileClasses: function() {\n_verbose('compiling classes');\n                var className;\n                while (className = this.queue[0]) {\n                    this.compile(className);\n                } // while\n                _.interpreter.defineClasses();\n                this._queue = [];\n            }, // compileClasses\n            compile: function(className) {\n                var index = this.queue.indexOf(className);\n                if (index >= 0) {\n                    this.queue.splice(index, 1);\n                    var classObject = global[className];\n_verbose('adding class', className);\n                    global._import = this._import;\n                    global._class = this._class;\n                    if (classObject._script.indexOf('_class') > -1 || classObject._script.indexOf('_import') > -1) {\n                        eval(classObject._script);\n                    }\n                    this.buffer = this.buffer.concat(classObject._script);\n_verbose(this.buffer.length, 'bytes', this.queue.length, 'scripts remain.');\n                } // if\n            } //compile\n        }, // compiler\n        interpreter: {\n            initializing: false,\n            _import: function(classPath) { //--------------------------------------------------------------- interpreter._import (null)\n_verbose('skipping import: ', classPath);\n            }, // _import\n            _class: function(className, properties) { //--------------------------------------------------------------- interpreter._class define\n_verbose('_class', className);\n                if (global[className] && global[className]._constructor) { // if class is stub\n                    return;\n                }\n                else {\n                    var newClass = Class._plus(className, properties); // create the class from Class object\n                    newClass._extends = function(parentClassName, properties) {\n_verbose('_extends', parentClassName);\n                        global[className] = global[parentClassName]._plus(className, properties);\n                        global[className]._className = className;\n                    }; // _extends\n                    global[className] = newClass;\n                } //if\n                _.interpreter.applicationName = className;\n                return global[className];\n            }, // _class\n            defineClasses: function() {\n_verbose('defining classes');\n                global._import = this._import; // null\n                global._class = this._class; // define / extend class\n                eval(_.compiler.buffer);\n                _.compiler.buffer = '';\n                Code.x();\n            } //defineClasses\n        } // interpreter\n    }; // _\n    global.DebugLevels = {\n        SILENT: 0,\n        ERRORS: 1,\n        WARNINGS: 2,\n        DEBUG: 3,\n        INFO: 4,\n        VERBOSE: 5\n    };\n    _trace = function() {\n        var output = \"\";\n        var args = arguments;\n        for (var index in args) {\n            var token = _.util.stringify(args[index]);\n            output += token + (' ');\n        } // for\n        console.log(output);\n    }; // _trace\n\n    _error = function() {\n        if (_.debugging >= DebugLevels.ERRORS) _trace.apply(this, arguments);\n    }; //\n    _warn = function() {\n        if (_.debugging >= DebugLevels.WARNINGS) _trace.apply(this, arguments);\n    }; //\n    _info = function() {\n        if (_.debugging >= DebugLevels.INFO) _trace.apply(this, arguments);\n    }; //\n    _debug = function() {\n        if (_.debugging >= DebugLevels.DEBUG) _trace.apply(this, arguments);\n    }; //\n    _verbose = function() {\n        if (_.debugging >= DebugLevels.VERBOSE) _trace.apply(this, arguments);\n    }; //\n\n    _package = function() { // Future Use\n_verbose('package', arguments[0]);\n    }; // _package\n\n\n    // DON'T GET CUTE.\n\n\n    /*\n     *\n     * Class is a modification of 'Class'\n     * originally by the immortal John Resig\n     *\n     * http://bit.ly/4U5H\n     *\n     *\n     */\n    //var fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n    // The base Class implementation --\n    // provides _get and _set shortcuts to eliminate abiguous assignment ( is it a property or a getterSetter ? )\n    // provides .add() to replace +=\n    var Class = function() {};\n    Class._className = 'Class';\n    Class.prototype = {\n        _get: function(propertyName) {\n            var property = this[propertyName];\n            if (property === undefined) {\n                return undefined;\n            }\n            return (typeof this[propertyName] == 'function') ? this[propertyName]() : this[propertyName];\n        },\n        _set: function(propertyName, value) {\n            var property = this[propertyName];\n            if (property === undefined) {\n                this[propertyName] = value;\n            }\n            else {\n                (typeof this[propertyName] == 'function') ? this[propertyName](value) : this[propertyName] = value;\n            }\n\n        },\n        _add: function(value, propertyName) {\n            value = value || 1;\n            var property = this[propertyName];\n            if (property === undefined) {\n                this[propertyName] = value;\n            }\n            else {\n                (typeof this[propertyName] == 'function') ? this[propertyName](this[propertyName]() + value) : this[propertyName] += value;\n            }\n        },\n        toString: function() {\n            return '[' + this._className + ']';\n        }\n    };\n\n    // Create a new Class that inherits from this class\n    Class._plus = function(className, additions) {\n        // Instantiate a base class (but only create the instance,\n        // don't run the __init__ constructor)\n        _.interpreter.initializing = true;\n        var newPrototype = new this();\n        _.interpreter.initializing = false;\n        newPrototype._className = className;\n        var superPrototype = this.prototype;\n\n        newPrototype._ = superPrototype._ ? _.util.deepCopy(superPrototype._) : {}; // private space\n        newPrototype.__ = superPrototype.__ ? _.util.deepCopy(superPrototype.__) : {\n            getters: {},\n            setters: {},\n            getSetterNames: []\n        }; // getters/setters space\n\n        // TODO: getter/setters proper\n\n        for (var name in additions) {\n            var addition = additions[name];\n            var propertyKeyword;\n            var propertyType;\n            var propertyName = name;\n            var propertyDefault = '[function]';\n            var attachTarget = {};\n\n            // TODO: getter/setters proper ?\n\n            if (name.indexOf('private_') >= 0) {\n                propertyKeyword = 'private';\n                propertyName = name.substring(name.indexOf(propertyKeyword) + propertyKeyword.length + 1, name.length);\n                attachTarget = newPrototype._;\n            }\n            else if (name.indexOf('static_') >= 0) {\n                propertyKeyword = 'static';\n                attachTarget = ClassObject;\n                propertyName = name.substring(name.indexOf(propertyKeyword) + propertyKeyword.length + 1, name.length);\n            }\n            else if (name.indexOf('get_') >= 0) {\n                propertyKeyword = 'get';\n                attachTarget = newPrototype.__.getters;\n                propertyName = name.substring(name.indexOf(propertyKeyword) + propertyKeyword.length + 1, name.length);\n                if (newPrototype.__.getSetterNames.indexOf(propertyName) == -1) {\n                    newPrototype.__.getSetterNames.push(propertyName);\n                }\n            }\n            else if (name.indexOf('set_') >= 0) {\n                propertyKeyword = 'set';\n                attachTarget = newPrototype.__.setters;\n                propertyName = name.substring(name.indexOf(propertyKeyword) + propertyKeyword.length + 1, name.length);\n                if (newPrototype.__.getSetterNames.indexOf(propertyName) == -1) {\n                    newPrototype.__.getSetterNames.push(propertyName);\n                }\n            }\n            else if (name === className) {\n                propertyKeyword = 'constructor';\n                attachTarget = newPrototype;\n                propertyName = '__init__';\n            }\n            else {\n                propertyKeyword = 'public';\n                attachTarget = newPrototype;\n            }\n            var property;\n            if (typeof addition == 'function') {\n                propertyType = 'function';\n                property = ( function(propertyName, fn, _super) {\n                    return function() {\n                        var args = '';\n                        for (var i in arguments) {\n                            args += _.util.stringify(arguments[i]) + ',';\n                        }\n                        args = args.slice(0, - 1);\n_verbose(className + '.' + propertyName + '( ' + args + ' )');\n                        var tmp = this._super;\n                        // Allow this._super() to call superconstructor, and allow this._super().*() to call the super method\n                        this._super = function() {\n                            if (propertyName === '__init__') {\n                                var __init__ = _super.__init__ || function() {};\n                                _super = _super._superPrototype;\n                                return __init__.apply(this, arguments)\n                            }\n                            else {\n                                var names = [];\n                                var sup = {};\n                                for (var memberName in _super) {\n                                    var member = _super[memberName];\n                                    if (typeof member === 'function') {\n                                        sup[memberName] = _.util.scope(member, this, memberName);\n                                        names.push(memberName);\n                                    }\n                                }\n                                _super = _super._superPrototype;\n                                return sup;\n                            }\n                        };\n                        // The __init__ method only need to be bound temporarily, so we\n                        // remove it when we're done executing\n                        var ret = fn.apply(this, arguments);\n                        this._super = tmp;\n                        _super = superPrototype;\n                        return ret;\n                    };\n                })(propertyName, addition, superPrototype);\n            }\n            else {\n                propertyType = 'var';\n                propertyDefault = addition;\n                property = _.util.deepCopy(addition);\n            }\n            attachTarget[propertyName] = property;\n_verbose('\\t', propertyKeyword, propertyType, propertyName, '=', propertyDefault);\n        }\n\n        // Create getter / setter properties\n        for (var index in newPrototype.__.getSetterNames) {\n            var getSetterName = newPrototype.__.getSetterNames[index];\n_verbose('property name:', getSetterName);\n            var getter = newPrototype.__.getters[getSetterName];\n_verbose('getter function:', getter);\n            var setter = newPrototype.__.setters[getSetterName];\n_verbose('setter function:', setter);\n            newPrototype[getSetterName] = (function(getter, setter, getSetterName) {\n                return function(value) {\n                    if (value === undefined) {\n                        if (getter) {\n_verbose('getting', getSetterName, 'of', this, ':', getter());\n                            return getter.call(this);\n                        }\n                        else return;\n                    }\n                    if (setter) {\n_verbose('setting', getSetterName, 'of', this, 'to', value);\n                        setter.call(this, value);\n                    }\n                }\n            })(getter, setter, getSetterName);\n        };\n        // The dummy class constructor (scoping)\n        function ClassObject() {\n            // All construction is actually done in the __init__ method (declared using the new Class name as string ( _className ) )\n            this._ = _.util.deepCopy(this._);\n            this.__ = _.util.deepCopy(this.__);\n            if (!_.interpreter.initializing) {\n_verbose('new', this._className);\n                if (this._className.indexOf('Event') < 0 && ['Dictionary'].indexOf(this._className) < 0) {\n                    // XXX What's this for?\n                }\n                for (var propertyName in this) {\n                    var property = this[propertyName];\n                    if (_.util.isMethod(property) && ['toString', '_get', '_set', '_add'].indexOf(propertyName) < 0) {\n_verbose('scoping public', propertyName)\n                        this[propertyName] = _.util.scope(property, this, propertyName);\n                    } //if\n                } //for\n\n                for (propertyName in this._) {\n                    var property = this._[propertyName];\n                    if (_.util.isMethod(property)) {\n_verbose('scoping private', propertyName)\n                        this._[propertyName] = _.util.scope(property, this);\n                    } //if\n                } //for\n                if (this.__init__) {\n                    this.__init__.apply(this, arguments);\n                } //if\n            } //if\n        }\n        //inheritance chain\n        newPrototype._superPrototype = superPrototype;\n        // Populate our constructed prototype object\n        ClassObject.prototype = newPrototype;\n\n        // Enforce the constructor to be what we expect\n        ClassObject.constructor = ClassObject;\n\n        // And make this class extensible\n        ClassObject._plus = arguments.callee;\n\n        return ClassObject;\n    };\n\n    var Code = function() {\n        return Code.c('Code');\n    };\n    Code.r = function(applicationClassPath, parameters) {\n_verbose('Code.r(', applicationClassPath, ',', _.util.stringify(parameters), ')');\n        _.application.parameters = parameters;\n        _.application.classPath = applicationClassPath;\n        global._import = _.loader._import;\n        _import(applicationClassPath);\n\n    };\n    Code.x = function(applicationClassPath, parameters) {\n_verbose('Code.x(', applicationClassPath, ',', _.util.stringify(parameters), ')');\n        parameters = parameters || this._.application.parameters;\n        applicationClassPath = applicationClassPath || this._.application.classPath;\n        var applicationClassName = applicationClassPath.split('.').pop();\n        new global[applicationClassName](parameters); //no namespace\n        _.application = {};\n    };\n    Code.c = function(applicationClassPath) {\n_verbose('Code.c(', applicationClassPath, ')');\n        var libPath = 'lib/' + applicationClassPath + '.js';\n        var buffer;\n        if (fs) {\n            try {\n                buffer = fs.readFileSync(libPath, 'ascii');\n            }\n            catch (e) {\n_verbose('no library at', libPath);\n            }\n        }\n        if (!buffer) {\n            var interpreter = _.interpreter;\n            _.interpreter = {\n                defineClasses: function() {\n_verbose('bypassing interpreter.');\n                }\n            };\n            global._import = _.loader._import;\n            _import(applicationClassPath);\n            buffer = _.compiler.buffer;\n            if (fs && path) {\n                if (!path.existsSync('lib/')) {\n_verbose('creating lib folder')\n                    fs.mkdirSync('lib/');\n                }\n_verbose('saving lib file to', libPath)\n                fs.writeFileSync(libPath, buffer)\n            }\n            _.compiler.buffer = '';\n            _.interpreter = interpreter;\n        }\n        return buffer;\n    };\n    Code._ = _;\n    global.Code = Code;\n    global._import = _.interpreter._import;\n    global._class = _.interpreter._class;\n_info('Code.js is ready. @2013 Neuromantic, LLC. All Rights reserved. Licenced under the MIT license.')\n\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////// Goin' Deep /////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////\n\n    //\t DEEP COPY props http://oranlooney.com/deep-copy-javascript/\n    //\t   This section is part of OWL JavaScript Utilities.\n    //\n    //\tOWL JavaScript Utilities is free software: you can redistribute it and/or\n    //\tmodify it under the terms of the GNU Lesser General Public License\n    //\tas published by the Free Software Foundation, either version 3 of\n    //\tthe License, or (at your option) any later version.\n    //\n    //\tOWL JavaScript Utilities is distributed in the hope that it will be useful,\n    //\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n    //\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    //\tGNU Lesser General Public License for more details.\n    //\n    //\tTo receive a copy of the GNU Lesser General Public License, see: <http://www.gnu.org/licenses/>.\n\n    //\t the re-usable constructor function used by clone().\n    function Clone() {}\n\n    //\t clone objects, skip other types.\n    function clone(target) {\n        if (typeof target == 'object') {\n            Clone.prototype = target;\n            return new Clone();\n        }\n        else {\n            return target;\n        }\n    }\n\n\n    //\t Shallow Copy\n    function copy(target) {\n        var c;\n        if (typeof target !== 'object') {\n            return target; // non-object have value sematics, so target is already a copy.\n        }\n        else {\n            var value = target.valueOf();\n            if (target != value) {\n                //\t\t\t\t the object is a standard object wrapper for a native type, say String.\n                //\t\t\t\t we can make a copy by instantiating a new object around the value.\n                return new target.constructor(value);\n            }\n            else {\n                //\t\t\t\t ok, we have a normal object. If possible, we'll clone the original's prototype\n                //\t\t\t\t (not the original) to get an empty object with the same prototype chain as\n                //\t\t\t\t the original.  If just copy the instance properties.  Otherwise, we have to\n                //\t\t\t\t copy the whole thing, property-by-property.\n                if (target instanceof target.constructor && target.constructor !== Object) {\n                    c = clone(target.constructor.prototype);\n                    //\t\t\t\t\t give the copy all the instance properties of target.  It has the same\n                    //\t\t\t\t\t prototype as target, so inherited properties are already there.\n                    for (var property in target) {\n                        if (target.hasOwnProperty(property)) {\n                            c[property] = target[property];\n                        }\n                    }\n                }else {\n                    c = {};\n                    for (var property in target) c[property] = target[property];\n                }\n                return c;\n            }\n        }\n    }\n    //\t Deep Copy\n    var deepCopiers = [];\n\n    function DeepCopier(config) {\n        for (var key in config) this[key] = config[key];\n    }\n    DeepCopier.prototype = {\n        constructor: DeepCopier,\n\n        //\t\t determines if this DeepCopier can handle the given object.\n        canCopy: function(source) {\n            return false;\n        },\n\n        //\t\t starts the deep copying process by creating the copy object.  You\n        //\t\t can initialize any properties you want, but you can't call recursively\n        //\t\t into the DeeopCopyAlgorithm.\n        create: function(source) {},\n\n        //\t\t Completes the deep copy of the source object by populating any properties\n        //\t\t that need to be recursively deep copied.  You can do this by using the\n        //\t\t provided deepCopyAlgorithm instance's deepCopy() method.  This will handle\n        //\t\t cyclic references for objects already deepCopied, including the source object\n        //\t\t itself.  The \"result\" passed in is the object returned from create().\n        populate: function(deepCopyAlgorithm, source, result) {}\n    };\n\n    function DeepCopyAlgorithm() {\n        //\t\t copiedObjects keeps track of objects already copied by this\n        //\t\t deepCopy operation, so we can correctly handle cyclic references.\n        this.copiedObjects = [];\n        this.recursiveDeepCopy = function(source) {\n            return this.deepCopy(source);\n        };\n        this.depth = 0;\n    }\n    DeepCopyAlgorithm.prototype = {\n        constructor: DeepCopyAlgorithm,\n        maxDepth: 256,\n        //\t\t add an object to the cache.  No attempt is made to filter duplicates;\n        //\t\t we always check getCachedResult() before calling it.\n        cacheResult: function(source, result) {\n            this.copiedObjects.push([source, result]);\n        },\n        //\t\t Returns the cached copy of a given object, or undefined if it's an\n        //\t\t object we haven't seen before.\n        getCachedResult: function(source) {\n            var copiedObjects = this.copiedObjects;\n            var length = copiedObjects.length;\n            for (var i = 0; i < length; i++) {\n                if (copiedObjects[i][0] === source) {\n                    return copiedObjects[i][1];\n                }\n            }\n            return undefined;\n        },\n\n        //\t\t deepCopy handles the simple cases itself: non-objects and object's we've seen before.\n        //\t\t For complex cases, it first identifies an appropriate DeepCopier, then calls\n        //\t\t applyDeepCopier() to delegate the details of copying the object to that DeepCopier.\n        deepCopy: function(source) {\n            //\t\t\t null is a special case: it's the only value of type 'object' without properties.\n            if (source === null) return null;\n\n            //\t\t\t All non-objects use value semantics and don't need explict copying.\n            if (typeof source !== 'object') return source;\n\n            var cachedResult = this.getCachedResult(source);\n\n            //\t\t\t we've already seen this object during this deep copy operation\n            //\t\t\t so can immediately return the result.  This preserves the cyclic\n            //\t\t\t reference structure and protects us from infinite recursion.\n            if (cachedResult) return cachedResult;\n\n            //\t\t\t objects may need special handling depending on their class.  There is\n            //\t\t\t a class of handlers call \"DeepCopiers\"  that know how to copy certain\n            //\t\t\t objects.  There is also a final, generic deep copier that can handle any object.\n            for (var i = 0; i < deepCopiers.length; i++) {\n                var deepCopier = deepCopiers[i];\n                if (deepCopier.canCopy(source)) {\n                    return this.applyDeepCopier(deepCopier, source);\n                }\n            }\n            // the generic copier can handle anything, so we should never reach this line.\n            throw new Error(\"no DeepCopier is able to copy \" + source);\n        },\n\n        //\t\t once we've identified which DeepCopier to use, we need to call it in a very\n        //\t\t particular order: create, cache, populate.  This is the key to detecting cycles.\n        //\t\t We also keep track of recursion depth when calling the potentially recursive\n        //\t\t populate(): this is a fail-fast to prevent an infinite loop from consuming all\n        //\t\t available memory and crashing or slowing down the browser.\n        applyDeepCopier: function(deepCopier, source) {\n            //\t\t\t Start by creating a stub object that represents the copy.\n            var result = deepCopier.create(source);\n\n            //\t\t\t we now know the deep copy of source should always be result, so if we encounter\n            //\t\t\t source again during this deep copy we can immediately use result instead of\n            //\t\t\t descending into it recursively.\n            this.cacheResult(source, result);\n\n            //\t\t\t only DeepCopier::populate() can recursively deep copy.  So, to keep track\n            //\t\t\t of recursion depth, we increment this shared counter before calling it,\n            //\t\t\t and decrement it afterwards.\n            this.depth++;\n            if (this.depth > this.maxDepth) {\n                throw new Error(\"Exceeded max recursion depth in deep copy.\");\n            }\n\n            //\t\t\t It's now safe to let the deepCopier recursively deep copy its properties.\n            deepCopier.populate(this.recursiveDeepCopy, source, result);\n\n            this.depth--;\n\n            return result;\n        }\n    };\n\n    //\t entry point for deep copy.\n    //\t   source is the object to be deep copied.\n    //\t   maxDepth is an optional recursion limit. Defaults to 256.\n    function deepCopy(source, maxDepth) {\n        var deepCopyAlgorithm = new DeepCopyAlgorithm();\n        if (maxDepth) deepCopyAlgorithm.maxDepth = maxDepth;\n        return deepCopyAlgorithm.deepCopy(source);\n    }\n\n    //\t publicly expose the DeepCopier class.\n    deepCopy.DeepCopier = DeepCopier;\n\n    //\t publicly expose the list of deepCopiers.\n    deepCopy.deepCopiers = deepCopiers;\n\n    //\t make deepCopy() extensible by allowing others to\n    //\t register their own custom DeepCopiers.\n    deepCopy.register = function(deepCopier) {\n        if (!(deepCopier instanceof DeepCopier)) {\n            deepCopier = new DeepCopier(deepCopier);\n        }\n        deepCopiers.unshift(deepCopier);\n    }\n\n    //\t Generic Object copier\n    //\t the ultimate fallback DeepCopier, which tries to handle the generic case.  This\n    //\t should work for base Objects and many user-defined classes.\n    deepCopy.register({\n        canCopy: function(source) {\n            return true;\n        },\n\n        create: function(source) {\n            if (source instanceof source.constructor) {\n                return clone(source.constructor.prototype);\n            }\n            else {\n                return {};\n            }\n        },\n\n        populate: function(deepCopy, source, result) {\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = deepCopy(source[key]);\n                }\n            }\n            return result;\n        }\n    });\n\n    //\t Array copier\n    deepCopy.register({\n        canCopy: function(source) {\n            return (source instanceof Array);\n        },\n\n        create: function(source) {\n            return new source.constructor();\n        },\n\n        populate: function(deepCopy, source, result) {\n            for (var i = 0; i < source.length; i++) {\n                result.push(deepCopy(source[i]));\n            }\n            return result;\n        }\n    });\n\n    //\t Date copier\n    deepCopy.register({\n        canCopy: function(source) {\n            return (source instanceof Date);\n        },\n\n        create: function(source) {\n            return new Date(source);\n        }\n    });\n\n    //\t HTML DOM Node\n\n    //\t utility function to detect Nodes.  In particular, we're looking\n    //\t for the cloneNode method.  The global document is also defined to\n    //\t be a Node, but is a special case in many ways.\n    function isNode(source) {\n        if (global.Node) {\n            return source instanceof Node;\n        }\n        else {\n            // the document is a special Node and doesn't have many of\n            // the common properties so we use an identity check instead.\n            if (typeof document == 'object' && source === document) return true;\n            return (\n            typeof source.nodeType === 'number' && source.attributes && source.childNodes && source.cloneNode);\n        }\n    }\n\n    //\t Node copier\n    deepCopy.register({\n        canCopy: function(source) {\n            return isNode(source);\n        },\n\n        create: function(source) {\n            //\t\t\t there can only be one (document).\n            if (typeof document == 'object' && source === document) return document;\n            //\t\t\t start with a shallow copy.  We'll handle the deep copy of\n            //\t\t\t its children ourselves.\n            return source.cloneNode(false);\n        },\n\n        populate: function(deepCopy, source, result) {\n            //\t\t\t we're not copying the global document, so don't have to populate it either.\n            if (typeof document == 'object' && source === document) return document;\n            //\t\t\t if this Node has children, deep copy them one-by-one.\n            if (source.childNodes && source.childNodes.length) {\n                for (var i = 0; i < source.childNodes.length; i++) {\n                    var childCopy = deepCopy(source.childNodes[i]);\n                    result.appendChild(childCopy);\n                }\n            }\n        }\n    });\n\n    // Code.js : Fase Dictionary\n    deepCopy.register({\n        canCopy: function(source) {\n            return source._className == 'Dictionary';\n        },\n        create: function() {\n            return new Dictionary();\n        },\n        populate: function(deepCopy, source, result) {\n            for (var i in source._keys) {\n                result._keys[i] = source._keys[i];\n                result._values[i] = deepCopy(source.values[i])\n            };\n        }\n    });\n    "],[0,"retu"]],"start1":600,"start2":600,"length1":30659,"length2":38056}]],"length":38670,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357772406934,"patch":[[{"diffs":[[0,"edObjects = [];\n"],[1,"        var _this = this;\n"],[0,"        this.rec"]],"start1":29798,"start2":29798,"length1":32,"length2":58},{"diffs":[[0,"     return "],[1,"_"],[0,"this.deepCop"]],"start1":29899,"start2":29899,"length1":24,"length2":25}]],"length":38697,"saved":false}
{"contributors":[],"silentsave":false,"ts":1358278557916,"patch":[[{"diffs":[[0,"sPath, '"],[1,"successfully"],[0,". proces"]],"start1":7626,"start2":7626,"length1":16,"length2":28},{"diffs":[[0,"eval(code);\n"],[1,"                    }else{\n_verbose( 'not a Code classfile or no imports present, skipping.');\n"],[0,"            "]],"start1":7961,"start2":7961,"length1":24,"length2":119}]],"length":38804,"saved":false}
{"ts":1358278666169,"patch":[[{"diffs":[[0,"'_import"],[1,"("],[0,"') > -1 "],[-1,"||"],[1,"&&"],[0," code.in"]],"start1":7887,"start2":7887,"length1":26,"length2":27},{"diffs":[[0,"exOf('_class"],[1,"("],[0,"') > -1) {\n "]],"start1":7915,"start2":7915,"length1":24,"length2":25}]],"length":38806,"saved":false}
{"ts":1358281209011,"patch":[[{"diffs":[[0,"\n *\n */\n"],[1," "],[0,"\n(functi"]],"start1":594,"start2":594,"length1":16,"length2":17},{"diffs":[[0,"obal : {"],[-1,"\n       "],[0," dev: nu"]],"start1":702,"start2":702,"length1":24,"length2":16},{"diffs":[[0,"ev: null"],[-1,"\n   "],[0," };\n    "]],"start1":712,"start2":712,"length1":20,"length2":16},{"diffs":[[0," -1 "],[-1,"&& code.indexOf('_class(') > -1"],[0,") {\n"]],"start1":7889,"start2":7889,"length1":39,"length2":8},{"diffs":[[0,"e( '"],[-1,"not a Code classfile or "],[0,"no i"]],"start1":7967,"start2":7967,"length1":32,"length2":8}]],"length":38740,"saved":false}
{"ts":1358285852615,"patch":[[{"diffs":[[0,"return s"],[1,";"],[0,"\n"],[-1,""],[0,"        "]],"start1":2748,"start2":2748,"length1":17,"length2":18},{"diffs":[[0,"ub)\n"],[-1,"                _verbose"],[1,"_debug"],[0,"('cr"]],"start1":3819,"start2":3819,"length1":32,"length2":14},{"diffs":[[0,"ame) {\n_"],[-1,"verbose"],[1,"debug"],[0,"('which "]],"start1":3943,"start2":3943,"length1":23,"length2":21},{"diffs":[[0,"on(classPath) {\n"],[1,"_debug('loading', classPath)\n"],[0,"                "]],"start1":4265,"start2":4265,"length1":32,"length2":61},{"diffs":[[0,"') > -1 ) {\n"],[1,"_verbose( 'found import statement(s), performing them..');\n"],[0,"            "]],"start1":7895,"start2":7895,"length1":24,"length2":83},{"diffs":[[0," = function() {\n"],[1,"        arguments.unshift('ERROR::');\n"],[0,"        if (_.de"]],"start1":12360,"start2":12360,"length1":32,"length2":70},{"diffs":[[0," = function() {\n"],[1,"        arguments.unshift('WARNING::');\n"],[0,"        if (_.de"]],"start1":12511,"start2":12511,"length1":32,"length2":72},{"diffs":[[0," = function() {\n"],[1,"        arguments.unshift('INFO::');\n"],[0,"        if (_.de"]],"start1":12666,"start2":12666,"length1":32,"length2":69},{"diffs":[[0," = function() {\n"],[1,"        arguments.unshift('DEBUG::');\n"],[0,"        if (_.de"]],"start1":12815,"start2":12815,"length1":32,"length2":70},{"diffs":[[0,";\n    }; //\n"],[-1,""],[0,"    _verbose"]],"start1":12944,"start2":12944,"length1":24,"length2":24},{"diffs":[[0," = function() {\n"],[1,"        arguments.unshift('VERBOSE::');\n"],[0,"        if (_.de"]],"start1":12968,"start2":12968,"length1":32,"length2":72}]],"length":39002,"saved":false}
{"ts":1358286120949,"patch":[[{"diffs":[[0,") {\n        "],[-1,"argument"],[1,"var args = Array.prototype.slice.call(arguments);\n        arg"],[0,"s.unshift('E"]],"start1":12372,"start2":12372,"length1":32,"length2":85},{"diffs":[[0," _trace."],[-1,"apply(this, arguments"],[1,"call( args "],[0,");\n    }"]],"start1":12513,"start2":12513,"length1":37,"length2":27},{"diffs":[[0,") {\n        "],[-1,"argument"],[1,"var args = Array.prototype.slice.call(arguments);\n        arg"],[0,"s.unshift('W"]],"start1":12566,"start2":12566,"length1":32,"length2":85},{"diffs":[[0," _trace."],[-1,"apply(this, arguments"],[1,"call( args "],[0,");\n    }"]],"start1":12711,"start2":12711,"length1":37,"length2":27},{"diffs":[[0,") {\n        "],[-1,"argument"],[1,"var args = Array.prototype.slice.call(arguments);\n        arg"],[0,"s.unshift('I"]],"start1":12764,"start2":12764,"length1":32,"length2":85},{"diffs":[[0," _trace."],[-1,"apply(this, arguments"],[1,"call( args "],[0,");\n    }"]],"start1":12902,"start2":12902,"length1":37,"length2":27},{"diffs":[[0,") {\n        "],[-1,"argument"],[1,"var args = Array.prototype.slice.call(arguments);\n        arg"],[0,"s.unshift('D"]],"start1":12956,"start2":12956,"length1":32,"length2":85},{"diffs":[[0," _trace."],[-1,"apply(this, arguments"],[1,"call( args "],[0,");\n    }"]],"start1":13096,"start2":13096,"length1":37,"length2":27},{"diffs":[[0,"        "],[-1,"argument"],[1,"var args = Array.prototype.slice.call(arguments);\n        arg"],[0,"s.unshif"]],"start1":13156,"start2":13156,"length1":24,"length2":77},{"diffs":[[0," _trace."],[-1,"apply(this, arguments"],[1,"call( args "],[0,");\n    }"]],"start1":13296,"start2":13296,"length1":37,"length2":27}]],"length":39217,"saved":false}
{"ts":1358286550064,"patch":[[{"diffs":[[0,") {\n"],[-1,"        var args = Array.prototype.slice.call(arguments);\n        args.unshift('ERROR::');\n"],[0,"    "]],"start1":12372,"start2":12372,"length1":99,"length2":8},{"diffs":[[0,"ORS) _trace."],[-1,"call( args "],[1,"apply(this, arguments"],[0,");\n    }; //"]],"start1":12418,"start2":12418,"length1":35,"length2":45},{"diffs":[[0,") {\n"],[-1,"        var args = Array.prototype.slice.call(arguments);\n        args.unshift('WARNING::');\n"],[0,"    "]],"start1":12485,"start2":12485,"length1":101,"length2":8},{"diffs":[[0,"NGS) _trace."],[-1,"call( args "],[1,"apply(this, arguments"],[0,");\n    }; //"]],"start1":12533,"start2":12533,"length1":35,"length2":45},{"diffs":[[0,") {\n"],[-1,"        var args = Array.prototype.slice.call(arguments);\n        args.unshift('INFO::');\n"],[0,"    "]],"start1":12600,"start2":12600,"length1":98,"length2":8},{"diffs":[[0,"NFO) _trace."],[-1,"call( args "],[1,"apply(this, arguments"],[0,");\n    }; //"]],"start1":12644,"start2":12644,"length1":35,"length2":45},{"diffs":[[0,") {\n"],[-1,"        var args = Array.prototype.slice.call(arguments);\n        args.unshift('DEBUG::');\n"],[0,"    "]],"start1":12712,"start2":12712,"length1":99,"length2":8},{"diffs":[[0,"BUG) _trace."],[-1,"call( args "],[1,"apply(this, arguments"],[0,");\n    }; //"]],"start1":12757,"start2":12757,"length1":35,"length2":45},{"diffs":[[0,") {\n"],[-1,"        var args = Array.prototype.slice.call(arguments);\n        args.unshift('VERBOSE::');\n"],[0,"    "]],"start1":12827,"start2":12827,"length1":101,"length2":8},{"diffs":[[0,"ace."],[-1,"call( args "],[1,"apply(this, arguments"],[0,");\n "]],"start1":12882,"start2":12882,"length1":19,"length2":29}]],"length":38809,"saved":false}
{"ts":1358286630483,"patch":[[{"diffs":[[0,"g them.."],[1,"."],[0,"');\n    "]],"start1":7954,"start2":7954,"length1":16,"length2":17}]],"length":38810,"saved":false}
{"ts":1358286834461,"patch":[[{"diffs":[[0,"    if ("],[1,"classPath !== 'Code' && "],[0,"code.ind"]],"start1":7865,"start2":7865,"length1":16,"length2":40}]],"length":38834,"saved":false}
{"ts":1358287129229,"patch":[[{"diffs":[[0," imports');\n"],[1,"                if( classPath !== 'Code'){\n    "],[0,"            "]],"start1":7657,"start2":7657,"length1":24,"length2":71},{"diffs":[[0,"          try {\n"],[1,"    "],[0,"                "]],"start1":7722,"start2":7722,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"    "],[0,"global._class = "]],"start1":7804,"start2":7804,"length1":32,"length2":36},{"diffs":[[0,"            "],[1," "],[1,"   "],[0,"code = code."]],"start1":7868,"start2":7868,"length1":24,"length2":28},{"diffs":[[0,"    "],[1,"    "],[0,"if ("],[-1,"classPath !== 'Code' &&"],[0," cod"]],"start1":7924,"start2":7924,"length1":35,"length2":16},{"diffs":[[0,"'_import"],[-1,"("],[0,"') > -1 "]],"start1":7950,"start2":7950,"length1":17,"length2":16},{"diffs":[[0,"') > -1 ) {\n"],[1,"    "],[0,"_verbose( 'f"]],"start1":7958,"start2":7958,"length1":24,"length2":28},{"diffs":[[0,"            "],[1,"    "],[0,"eval(code);\n"]],"start1":8046,"start2":8046,"length1":24,"length2":28},{"diffs":[[0,"    "],[1,"    "],[0,"}else{\n"],[1,"    "],[0,"_ver"]],"start1":8090,"start2":8090,"length1":15,"length2":23},{"diffs":[[0,"                "],[-1,"}\n"],[1,"    }\n    "],[0,"                "]],"start1":8157,"start2":8157,"length1":34,"length2":42},{"diffs":[[0,"                "],[1,"    "],[0,"catch (error) {\n"]],"start1":8201,"start2":8201,"length1":32,"length2":36},{"diffs":[[0,"catch (error) {\n"],[1,"    "],[0,"_error('error co"]],"start1":8221,"start2":8221,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"   "],[1," "],[0,"throw error;\n   "]],"start1":8332,"start2":8332,"length1":32,"length2":36},{"diffs":[[0,"                "],[-1,"}\n"],[1,"    }\n    "],[0,"                "]],"start1":8365,"start2":8365,"length1":34,"length2":42},{"diffs":[[0,"                "],[1,"  "],[1,"  "],[0,"global[className"]],"start1":8451,"start2":8451,"length1":32,"length2":36},{"diffs":[[0,"ame] || {};\n"],[1,"    "],[0,"            "]],"start1":8504,"start2":8504,"length1":24,"length2":28},{"diffs":[[0,"                "],[1,"    "],[0,"_.compiler.queue"]],"start1":8585,"start2":8585,"length1":32,"length2":36},{"diffs":[[0,"                "],[1," "],[1,"   "],[0,"if (this.queue.l"]],"start1":8674,"start2":8674,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"    "],[0,"_.compiler.compi"]],"start1":8750,"start2":8750,"length1":32,"length2":36},{"diffs":[[0,"mpileClasses();\n"],[1,"    "],[0,"                "]],"start1":8783,"start2":8783,"length1":32,"length2":36},{"diffs":[[0,"            "],[1,"    "],[0,"} // if\n"],[1,"                }\n"],[0,"            "]],"start1":8844,"start2":8844,"length1":32,"length2":54}]],"length":38963,"saved":false}
{"ts":1358288842666,"patch":[[{"diffs":[[0,"        "],[-1,"DEBUG"],[1,"INFO"],[0,": 3,\n   "]],"start1":12172,"start2":12172,"length1":21,"length2":20},{"diffs":[[0,"        "],[-1,"INFO"],[1,"DEBUG"],[0,": 4,\n   "]],"start1":12189,"start2":12189,"length1":20,"length2":21},{"diffs":[[0," };\n    "],[1,"DebugLevels.LABELS = ['SILENT', 'ERROR', 'WARNING', 'INFO', 'DEBUG', 'VERBOSE'];\n    global."],[0,"_trace ="]],"start1":12229,"start2":12229,"length1":16,"length2":108}]],"length":39055,"saved":false}
{"ts":1358289139250,"patch":[[{"diffs":[[0,"assPath) {\n_"],[-1,"verbose"],[1,"debug"],[0,"('Code.c(', "]],"start1":24197,"start2":24197,"length1":31,"length2":29}]],"length":39053,"saved":false}
{"ts":1358289237580,"patch":[[{"diffs":[[0,"atch (e) {\n_"],[-1,"verbose"],[1,"debug"],[0,"('no library"]],"start1":24458,"start2":24458,"length1":31,"length2":29},{"diffs":[[0,"on() {\n_"],[-1,"verbose"],[1,"debug"],[0,"('bypass"]],"start1":24662,"start2":24662,"length1":23,"length2":21},{"diffs":[[0,"/')) {\n_"],[-1,"verbose"],[1,"debug"],[0,"('creati"]],"start1":24937,"start2":24937,"length1":23,"length2":21},{"diffs":[[0,"     }\n_"],[-1,"verbose"],[1,"debug"],[0,"('saving"]],"start1":25027,"start2":25027,"length1":23,"length2":21},{"diffs":[[0," buffer)"],[1,";"],[0,"\n       "]],"start1":25113,"start2":25113,"length1":16,"length2":17},{"diffs":[[0,"_class;\n"],[-1,"_info"],[1,"console.log"],[0,"('Code.j"]],"start1":25372,"start2":25372,"length1":21,"length2":27}]],"length":39052,"saved":false}
{"ts":1358289240257,"patch":[[{"diffs":[[0,"cense.')"],[1,";"],[0,"\n\n    //"]],"start1":25481,"start2":25481,"length1":16,"length2":17}]],"length":39053,"saved":false}
{"ts":1358289549239,"patch":[[{"diffs":[[0,"        } // if\n"],[1,"                }else{\n                    return code\n"],[0,"                "]],"start1":8852,"start2":8852,"length1":32,"length2":87},{"diffs":[[0," (fs"],[-1,") {\n            try"],[1," && path && path.fileExistsSync( libPath))"],[0," {\n "]],"start1":24400,"start2":24400,"length1":27,"length2":50},{"diffs":[[0,"    "],[-1,"    }\n            catch (e) {\n_debug"],[1,"}else{\n_warn"],[0,"('no"]],"start1":24513,"start2":24513,"length1":44,"length2":20},{"diffs":[[0,", libPath);\n"],[-1,"            }\n"],[0,"        }\n  "]],"start1":24545,"start2":24545,"length1":38,"length2":24},{"diffs":[[0,"on() {\n_"],[-1,"debug"],[1,"verbose"],[0,"('bypass"]],"start1":24702,"start2":24702,"length1":21,"length2":23}]],"length":39095,"saved":false}
{"ts":1358289645589,"patch":[[{"diffs":[[0,"ath."],[-1,"fileE"],[1,"e"],[0,"xist"]],"start1":24417,"start2":24417,"length1":13,"length2":9},{"diffs":[[0," libPath"],[-1,")"],[1," ) "],[0,") {\n    "]],"start1":24432,"start2":24432,"length1":17,"length2":19}]],"length":39093,"saved":false}
{"ts":1358289856422,"patch":[[{"diffs":[[0,"');\n"],[-1,"                if( classPath !== 'Code'){\n"],[0,"    "]],"start1":7665,"start2":7665,"length1":51,"length2":8},{"diffs":[[0,"      if"],[-1," "],[0,"("],[1," classPath !== 'Code' &&"],[0," code.in"]],"start1":7883,"start2":7883,"length1":18,"length2":41},{"diffs":[[0," if\n"],[-1,"                }else{\n                    return code\n"],[0,"    "]],"start1":8844,"start2":8844,"length1":63,"length2":8}]],"length":39018,"saved":false}
{"ts":1358289939235,"patch":[[{"diffs":[[0,"            "],[-1,"    "],[0,"try {\n"],[-1,"    "],[0,"            "]],"start1":7673,"start2":7673,"length1":38,"length2":30},{"diffs":[[0,"                "],[-1,"    "],[0,"global._class = "]],"start1":7753,"start2":7753,"length1":36,"length2":32},{"diffs":[[0,"            "],[-1,"  "],[-1,"  "],[0,"code = code."]],"start1":7813,"start2":7813,"length1":28,"length2":24},{"diffs":[[0,"ode.toString();\n"],[-1,"    "],[0,"                "]],"start1":7833,"start2":7833,"length1":36,"length2":32},{"diffs":[[0," -1 ) {\n"],[-1,"    "],[0,"_verbose"]],"start1":7922,"start2":7922,"length1":20,"length2":16},{"diffs":[[0," them...');\n"],[-1,"    "],[0,"            "]],"start1":7978,"start2":7978,"length1":28,"length2":24},{"diffs":[[0,"    "],[-1,"    "],[0,"}else{\n"],[-1,"    "],[0,"_ver"]],"start1":8042,"start2":8042,"length1":23,"length2":15},{"diffs":[[0,"            "],[-1,"    }\n  "],[1,"}\n"],[0,"            "]],"start1":8105,"start2":8105,"length1":32,"length2":26},{"diffs":[[0,"            "],[-1,"  }\n    "],[1,"}\n"],[0,"            "]],"start1":8123,"start2":8123,"length1":32,"length2":26},{"diffs":[[0,"rror) {\n"],[-1,"    "],[0,"_error('"]],"start1":8161,"start2":8161,"length1":20,"length2":16},{"diffs":[[0,"                "],[-1,"   "],[-1," "],[0,"throw error;\n   "]],"start1":8260,"start2":8260,"length1":36,"length2":32},{"diffs":[[0,"            "],[-1,"    }\n  "],[1,"}\n"],[0,"            "]],"start1":8293,"start2":8293,"length1":32,"length2":26},{"diffs":[[0,"                "],[-1,"  "],[0,"var className = "]],"start1":8307,"start2":8307,"length1":34,"length2":32},{"diffs":[[0,"lit('.').pop();\n"],[-1,"    "],[0,"                "]],"start1":8351,"start2":8351,"length1":36,"length2":32},{"diffs":[[0,"                "],[-1," "],[-1,"   "],[0,"global[className"]],"start1":8428,"start2":8428,"length1":36,"length2":32},{"diffs":[[0," script\n"],[-1,"    "],[0,"        "]],"start1":8485,"start2":8485,"length1":20,"length2":16},{"diffs":[[0,"                "],[-1,"    "],[0,"if (this.queue.l"]],"start1":8578,"start2":8578,"length1":36,"length2":32},{"diffs":[[0,"                "],[-1,"   "],[-1," "],[0,"_.compiler.compi"]],"start1":8650,"start2":8650,"length1":36,"length2":32},{"diffs":[[0,"mpileClasses();\n"],[-1,"    "],[0,"                "]],"start1":8679,"start2":8679,"length1":36,"length2":32},{"diffs":[[0,"    "],[-1,"    "],[0,"} // if\n"],[-1,"                }\n"],[0,"    "]],"start1":8744,"start2":8744,"length1":38,"length2":16}]],"length":38908,"saved":false}
{"ts":1358290377730,"patch":[[{"diffs":[[0,"    //\t "],[1,"HTML "],[0,"Node cop"]],"start1":37324,"start2":37324,"length1":16,"length2":21}]],"length":38913,"saved":false}
{"ts":1358290575993,"patch":[[{"diffs":[[0,"     try {\n_"],[-1,"verbose"],[1,"debug"],[0,"('looking fo"]],"start1":4665,"start2":4665,"length1":31,"length2":29},{"diffs":[[0," (e) {\n_"],[-1,"verbose"],[1,"debug"],[0,"('no byt"]],"start1":4836,"start2":4836,"length1":23,"length2":21},{"diffs":[[0," try {\n_"],[-1,"verbose"],[1,"debug"],[0,"('loadin"]],"start1":4904,"start2":4904,"length1":23,"length2":21},{"diffs":[[0,"     try {\n_"],[-1,"verbose"],[1,"debug"],[0,"('generating"]],"start1":5063,"start2":5063,"length1":31,"length2":29},{"diffs":[[0," names\n_"],[-1,"verbose"],[1,"debug"],[0,"('mangli"]],"start1":5478,"start2":5478,"length1":23,"length2":21},{"diffs":[[0,"ations\n_"],[-1,"verbose"],[1,"debug"],[0,"('squeez"]],"start1":5666,"start2":5666,"length1":23,"length2":21},{"diffs":[[0,"     }\n_"],[-1,"verbose"],[1,"debug"],[0,"('writin"]],"start1":6159,"start2":6159,"length1":23,"length2":21},{"diffs":[[0,"rror);\n_"],[-1,"v"],[0,"er"],[-1,"bose"],[1,"ror"],[0,"('error "]],"start1":6440,"start2":6440,"length1":23,"length2":21}]],"length":38897,"saved":false}
{"ts":1358290659026,"patch":[[{"diffs":[[0,"     try {\n_"],[-1,"debug"],[1,"verbose"],[0,"('looking fo"]],"start1":4665,"start2":4665,"length1":29,"length2":31},{"diffs":[[0," (e) {\n_"],[-1,"debug"],[1,"verbose"],[0,"('no byt"]],"start1":4838,"start2":4838,"length1":21,"length2":23},{"diffs":[[0,"     try {\n_"],[-1,"debug"],[1,"verbose"],[0,"('loading so"]],"start1":4904,"start2":4904,"length1":29,"length2":31},{"diffs":[[0," try {\n_"],[-1,"debug"],[1,"verbose"],[0,"('genera"]],"start1":5073,"start2":5073,"length1":21,"length2":23},{"diffs":[[0," names\n_"],[-1,"debug"],[1,"verbose"],[0,"('mangli"]],"start1":5486,"start2":5486,"length1":21,"length2":23},{"diffs":[[0,"ations\n_"],[-1,"debug"],[1,"verbose"],[0,"('squeez"]],"start1":5676,"start2":5676,"length1":21,"length2":23},{"diffs":[[0,"     }\n_"],[-1,"debug"],[1,"verbose"],[0,"('writin"]],"start1":6171,"start2":6171,"length1":21,"length2":23},{"diffs":[[0,"rror);\n_"],[1,"v"],[0,"er"],[-1,"ror"],[1,"bose"],[0,"('error "]],"start1":6454,"start2":6454,"length1":21,"length2":23},{"diffs":[[0,"//\t HTML"],[-1," "],[0,"Node cop"]],"start1":37328,"start2":37328,"length1":17,"length2":16}]],"length":38912,"saved":false}
