{"ts":1357250216598,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n *\n * Code.js\n * \n * Class / Object Descripion Engine for Javascript\n * \n * https://github.com/neuromantic/CodeJS\n *\n * Copyright 2012, Neuromantic Industries\n * Licensed under the MIT license.\n *\n */\n\n( function ( ) {\n\tglobal = ( typeof window == 'object') ? window : ( typeof global == 'object') ? global : { dev: null }; \n\tconsole = console || {};\n\tconsole.log = console.log || function () {};\n\tif ( typeof require == 'function' ) {\n\t\tfs = require( 'fs' );\n\t\tpath = require('path');\n\t\tast = require('uglify-js').parser;\n\t\tugg = require('uglify-js').uglify;\n\t\thttp = require( 'http' );\n\t}\n\tvar _ = {\n\t\tdebugging : true,\n\t\tapplication : {},\n\t\tutil : {\n\t\t\tstringify: function ( obj, done ){\n\t\t\t\tif ( typeof obj === 'undefined' ){\n\t\t\t\t\treturn '{undefined}';\n\t\t\t\t}\n\t\t\t\tif ( obj === null){\n\t\t\t\t\treturn '{null}';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( obj.tagName){\n\t\t\t\t\treturn '<' + obj.tagName + '/>';\n\t\t\t\t}\n\t\t\t\tif (obj._className){\n\t\t\t\t\treturn obj.toString();\n\t\t\t\t}\n\t\t\t\tswitch( typeof obj){\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tvar s = '{ ';\n\t\t\t\t\t\tfor (var key in obj ){\n\t\t\t\t\t\t\tvar val = obj[key];\n\t\t\t\t\t\t\tvar type = typeof val;\n\t\t\t\t\t\t\tif(done){\n\t\t\t\t\t\t\t\tval = ( type === 'array' || type === 'object' || type === 'function' ) ? type : val;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tval = type === 'string' ?  '\"' + obj +'\"' : _.util.stringify(val, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts+= ' ' + key + ' : ' + val + ',' ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\t\ts+=' }';\n\t\t\t\t\t\treturn s\n\t\t\t\t\tcase 'function':\n\t\t\t\t\t\treturn '[function]';\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\tvar s = '[ ';\n\t\t\t\t\t\tfor (var i = 0; i < obj.length; i++ ){\n\t\t\t\t\t\t\tvar val = obj[i];\n\t\t\t\t\t\t\tval = _.util.stringify(val, true);\n\t\t\t\t\t\t\ts+= ' ' + key + ' : ' + val + ',' ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = s.slice(0,-1);\n\t\t\t\t\t\ts+=' ]';\n\t\t\t\t\t\treturn s\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeepCopy : deepCopy,\n\t\t\tscope : function ( fn, scope, functionName ) {\n\t\t\t\treturn function () {\n\t\t\t\t\tvar s = '';\n\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\ts+=arguments[i]+\",\"\n\t\t\t\t\t}\n\t\t\t\t\ts = s.substring(0,-1)\n// _debug( scope + '.' + functionName+'(' + s + ')' );\n\t\t\t\t\t return fn.apply( scope, arguments );\n\t\t\t\t}//closure\n\t\t\t},//scope\n\t\t\tisMethod : function( property ) {\n\t\t\t\treturn ( ( typeof property == 'function' ) && ( ! ( property instanceof RegExp ) ) );\n\t\t\t}//isMethod\n\t\t},// util\n\t\tloader : {\n\t\t\tqueue : [],\n\t\t\t_import : function( classPath, immediately ) {//--------------------------------------------------------------- loader._import (load)\n\t\t\t\tif( _.loader.queue.indexOf( classPath ) < 0 ) {\n\t\t\t\t\t_.loader.load( classPath );// push path into loading queue\n\t\t\t\t}// if\n\t\t\t},// _import\n\t\t\t_class : function ( className ) {//--------------------------------------------------------------- loader._class (stub)\n//_debug( 'creating stub class for', className );\n\t\t\t\tvar stub = { \n\t\t\t\t\t_extends : function( superName ) {\n\t\t\t\t\t\tthis._super = superName;//set super name for definition tree\n\t\t\t\t\t}// _extends\n\t\t\t\t};// stub\n\t\t\t\tglobal[ className ] = stub;\n\t\t\t\treturn global[ className ];\n\t\t\t},// _class\n\t\t\tload : function( classPath, first ) {\n\t\t\t\tvar code, scriptPath;\n//TODO: http classPaths\n\t\t\t\tvar binPath = 'bin/' + classPath;\n\t\t\t\tscriptPath = 'src/' + classPath.replace( /\\./g, '/' ) + '.js';\n\t\t\t\ttry{\n\t\t\t\t\tthis.queue.push( classPath);\n\t\t\t\t\tif( fs && path && ast && ugg ){//server\n\t\t\t\t\t\ttry{\n//_debug( 'looking for bytecode in', binPath );\n\t\t\t\t\t\t\tcode = fs.readFileSync( binPath );\n\t\t\t\t\t\t}catch( e ){\n//_debug( 'no bytecode available.');\n\t\t\t\t\t\t\ttry{\n//_debug( 'loading source code from', scriptPath );\n\t\t\t\t\t\t\t\tcode = fs.readFileSync( scriptPath, 'ascii' );\n\t\t\t\t\t\t\t\ttry{\n//_debug( 'generating bytecode for', classPath );\t\n\t\t\t\t\t\t\t\t\tif( ! _.debugging ){\n\t\t\t\t\t\t\t\t\t\tcode = ast.parse( code ); // parse code and get the initial AST\n\t\t\t\t\t\t\t\t\t\tif(classPath == 'Code'){\n\t\t\t\t\t\t\t\t\t\t\tcode = ugg.ast_mangle( code ); // get a new AST with mangled names\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcode = ugg.ast_squeeze( code ); // get an AST with compression optimizations\n\t\t\t\t\t\t\t\t\t\tcode = ugg.gen_code( code ); // compressed code here\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(! path.existsSync( 'bin/' ) ){\n\t\t\t\t\t\t\t\t\t\tfs.mkdirSync( 'bin/');\n\t\t\t\t\t\t\t\t\t}\n//_debug( 'writing bytecode to', binPath, code );\n\t\t\t\t\t\t\t\t\tfs.writeFileSync( binPath, code );\n\t\t\t\t\t\t\t\t}catch (error ){\n\t\t\t\t\t\t\t\t\tthrow new Error( error );\n_debug( 'error creating bytecode' );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}catch( error ){\n_debug( 'file system error');\n\t\t\t\t\t\t\t\tthrow new Error( error );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {//client // ( typeof XMLHttpRequest == \"function\" )\n//_debug( 'streaming source code from', scriptURL );\n\t\t\t\t\t\tvar scriptURL = scriptPath;\n\t\t\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\t\t\trequest.open( 'GET', scriptURL, false );\n\t\t\t\t\t\trequest.send( null );\n\t\t\t\t\t\tif ( request.status == 200 ) {\n\t\t\t\t\t\t\tcode = request.responseText;\n\t\t\t\t\t\t} else {// else if\n_debug( 'XMLHttpRequest error');\n\t\t\t\t\t\t    throw new Error( request.status );\n\t\t\t\t\t\t};// else\n\t\t\t\t\t}  \n\t\t\t\t}catch( error ){\n_debug( 'error loading', classPath, ':', error.message ) ;\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n//_debug( 'loaded', classPath, '. processing imports' );\n\t\t\t\ttry{\n\t\t\t\t\tglobal._import = this._import;//load\n\t\t\t\t\tglobal._class = this._class;//stub\n\t\t\t\t\tcode = code.toString();\n\t\t\t\t\tif(code.indexOf('_import') > -1 || code.indexOf('_class') > -1){\n\t\t\t\t\t\teval( code );\n\t\t\t\t\t}\n\t\t\t\t}catch( error ){\n_debug( 'error completing imports for '+  classPath + '. Error Text:' + error.message );\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\tvar className = classPath.split( '.' ).pop();\n\t\t\t\tglobal[ className ] = global[ className ] || {}\n\t\t\t\tglobal[ className ]._script = code;//store script\n\t\t\t\t_.compiler.queue.push(className );// add script to compilation queue\n\t\t\t\tif( this.queue.length == _.compiler.queue.length ){\n\t\t\t\t\t_.compiler.compileClasses();\n\t\t\t\t\tthis.queue = [];\n\t\t\t\t}// if\n\t\t\t}//, load\n\t\t},// loader\n\t\tcompiler : {\n\t\t\tbuffer :'',\n\t\t\tqueue : [],\n\t\t\t_import : function( classPath, immediately ) {\n\t\t\t\tvar className = classPath.split( '.' ).pop();\n\t\t\t\t_.compiler.compile( className );\n\t\t\t},// _import\n\t\t\t_class : function( className ) {\n\t\t\t\treturn {_extends:function (){}}\n\t\t\t},// _import\n\t\t\tcompileClasses : function () {\n//_debug( 'compiling classes' );\n\t\t\t\tvar className;\n\t\t\t\twhile ( className = this.queue[ 0 ] ) {\n\t\t\t\t\tthis.compile( className );\n\t\t\t\t}// while\n\t\t\t\t _.interpreter.defineClasses();\n\t\t\t\t this._queue = [];\n\t\t\t},// compileClasses\n\t\t\tcompile : function ( className ) {\n\t\t\t\tvar index = this.queue.indexOf( className );\n\t\t\t\tif ( index >= 0 ) {\n\t\t\t\t\tthis.queue.splice( index, 1 );\n\t\t\t\t\tvar classObject = global [ className ];\n//_debug( 'adding class', className );\n\t\t\t\t\tglobal._import = this._import;\n\t\t\t\t\tglobal._class = this._class;\n\t\t\t\t\tif( classObject._script.indexOf ('_class') > -1 || classObject._script.indexOf('_import') > -1 ){\n\t\t\t\t\t\teval( classObject._script );\n\t\t\t\t\t}\n\t\t\t\t\tthis.buffer = this.buffer.concat( classObject._script );\n//_debug( this.buffer.length, 'bytes', this.queue.length, 'scripts remain.' );\n\t\t\t\t}// if\n\t\t\t}//compile\n\t\t},// compiler\n\t\tinterpreter : {\n\t\t\tinitializing : false,\n\t\t\t_import : function( classPath, immediately ) {//--------------------------------------------------------------- interpreter._import (null)\n\t\t\t},// _import\n\t\t\t_class : function( className, properties ) {//--------------------------------------------------------------- interpreter._class define\n//_debug( '_class', className );\n\t\t\t\tif( global[ className ] &&  global[ className ]._constructor ) {// if class is stub\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tvar newClass = Class._plus( className, properties );// create the class from Class object\n\t\t\t\t\tnewClass._extends = function( parentClassName, properties ) {\n//_debug( '_extends', parentClassName );\n\t\t\t\t\t\t\tglobal[ className ] = global[ parentClassName ]._plus( className, properties );\n\t\t\t\t\t\t \tglobal[ className ]._className = className;\n\t\t\t\t\t}// _extends\n\t\t\t\t\tglobal[ className ] = newClass;\n\t\t\t\t} //if\n\t\t\t\t_.interpreter.applicationName = className;\n\t\t\t\treturn global[ className ]\n\t\t\t },// _class\n\t\t\tdefineClasses : function () {\n//_debug( 'defining classes' );\n\t\t\t\tglobal._import = this._import; // null\n\t\t\t\tglobal._class = this._class; // define / extend class\n\t\t\t\teval( _.compiler.buffer );\n\t\t\t\t_.compiler.buffer = '';\n\t\t\t\tCode.x();\n\t\t\t}//defineClasses\n\t\t}// interpreter\n\t};// _\n\t\n\t_trace = function () {\n\t\tvar output = \"\";\n\t\tvar args = arguments;\n\t\tfor( index in args ) {\n\t\t\tvar token = _.util.stringify(args[ index ]);\n\t\t\toutput += token + ( ' ' );\n\t\t};// for\n\t\tconsole.log( output );\n\t};// _trace\n\t\n\t_debug = function () {\n\t\tif( _.debugging ) _trace.apply( this, arguments );\n\t};//\n\t\n\t_package = function() { // Future Use\n// _trace( 'package', arguments[ 0 ] );\n\t};// _package\n\t\n\t\n\t// DON'T GET CUTE.\n\t\t\n\t/* \n\t * \n\t * Class is a modification of 'Class' \n\t * originally by the immortal John Resig\n\t * \n\t * http://bit.ly/4U5H\n\t *\t\n\t */\t\n//\t   var fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n\t  // The base Class implementation -- \n\t  // provides _get and _set shortcuts to eliminate abiguous assignment ( is it a  property or a getSetter ? )\n\t  // provides .add() to replace += \n\t  var Class = function(){};\n\t  Class._className = 'Class';\n\t  Class.prototype = {\n\t\t\t_get : function( propertyName ){\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t};\n\t\t\t\treturn ( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]() : this[ propertyName ];\n\t\t\t},\n\t\t\t_set : function( propertyName, value ){\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\tthis[propertyName] = value;\n\t\t\t\t}else{\n\t\t\t\t\t( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]( value ) : this[ propertyName ] = value;\n\t\t\t\t};\n\t\t\t\n\t\t\t},\n\t\t\t_add : function( value, propertyName ){\n\t\t\t\tvalue = value || 1;\n\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\tif (property  === undefined ) {\n\t\t\t\t\tthis[propertyName] = value;\n\t\t\t\t}else{\n\t\t\t\t\t( typeof this[ propertyName ] == 'function' ) ? this[ propertyName ]( this[ propertyName ]() + value ) : this[ propertyName ] += value;\n\t\t\t\t};\n\t\t\t},\n\t\t\ttoString : function () { return '['+this._className+']'; } \n\t\t};\n\t\t\n\t  // Create a new Class that inherits from this class\n\tClass._plus = function(className, additions) {\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the __init__ constructor)\n\t\t_.interpreter.initializing = true;\n\t\tvar newPrototype = new this();\n\t\t_.interpreter.initializing = false;\n\t\tnewPrototype._className = className;\n\t\tvar superPrototype =  this.prototype;\n\n\t\tnewPrototype._ = superPrototype._ ? _.util.deepCopy( superPrototype._ ) : {}; // private space\n\t\tnewPrototype.__ = superPrototype.__ ? _.util.deepCopy( superPrototype.__ ) : { getters : {}, setters: {}, getSetterNames:[] }; // getters/setters space\n\t\t\n\t\t// TODO: getter/setters proper\n\n\t\tfor (var name in additions) {\n\t\t\tvar addition = additions[ name ];\n\t\t\tvar\tpropertyKeyword;\n\t\t\tvar\tpropertyType;\n\t\t\tvar propertyName = name;\n\t\t\tvar propertyDefault = '[function]';\n\t\t\tvar attachTarget = {};\n\t\t\t\n\t\t// TODO: getter/setters proper ?\n\t\t\n\t\t\tif ( name.indexOf( 'private_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'private';\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tattachTarget = newPrototype._;\n\t\t\t} else if ( name.indexOf( 'static_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'static';\n\t\t\t\tattachTarget = ClassObject;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t}  else if ( name.indexOf( 'get_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'get';\n\t\t\t\tattachTarget = newPrototype.__.getters;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tif( newPrototype.__.getSetterNames.indexOf( propertyName ) == -1 ){\n\t\t\t\t\tnewPrototype.__.getSetterNames.push( propertyName );\n\t\t\t\t}\n\t\t\t}  else if ( name.indexOf( 'set_' ) >= 0 ) {\n\t\t\t\tpropertyKeyword = 'set';\n\t\t\t\tattachTarget = newPrototype.__.setters;\n\t\t\t\tpropertyName = name.substring( name.indexOf( propertyKeyword )  + propertyKeyword.length + 1 , name.length );\n\t\t\t\tif( newPrototype.__.getSetterNames.indexOf( propertyName ) == -1 ){\n\t\t\t\t\tnewPrototype.__.getSetterNames.push( propertyName );\n\t\t\t\t}\n\t\t\t} else if ( name === className ){\n\t\t\t\tpropertyKeyword = 'constructor';\n\t\t\t\tattachTarget = newPrototype;\n\t\t\t\tpropertyName = '__init__'\n\t\t\t} else {\n\t\t\t\tpropertyKeyword = 'public';\n\t\t\t\tattachTarget = newPrototype;\n\t\t\t};\n\n\t\t\tvar property;\n\t\t\tif ( typeof addition == 'function'  ) {\n\t\t      \tpropertyType = 'function';\n\t\t      \tproperty = ( function( propertyName, fn, _super ){\n\t\t\t        return function() {\n\t\t\t            var tmp = this._super;\n\t\t\t            // Allow this._super() to call superconstructor, and allow this._super().*() to call the super method\n\t\t\t\t        this._super = function(){\n\t\t\t            \tif( propertyName === '__init__' ) {\n\t\t\t\t\t\t\t\tvar __init__ = _super.__init__ || function(){};\n\t\t\t\t\t\t\t\t_super = _super._superPrototype;\n\t\t            \t\t\treturn __init__.apply( this, arguments)\n\t\t\t\t            }else{\n\t\t\t\t            \tvar names = [];\n\t\t\t\t            \tvar sup = {};\n\t\t\t\t            \tfor( var memberName in _super ){\n\t\t\t\t            \t\tvar member = _super[ memberName ]\n\t\t\t\t            \t\tif( typeof member === 'function' ){\n\t\t\t\t            \t\t\tsup[ memberName ] = _.util.scope( member, this, memberName );\n\t\t\t\t\t            \t\tnames.push(memberName)\n\t\t\t\t            \t\t}\n\t\t\t\t            \t}\n\t\t\t\t            \t_super = _super._superPrototype;\n\t\t\t\t            \treturn sup\n\t\t\t\t            }\n\t\t\t            }\n\t\t\t            // The __init__ method only need to be bound temporarily, so we\n\t\t\t            // remove it when we're done executing\n\t\t\t            var ret = fn.apply( this, arguments );        \n\t\t\t            this._super = tmp;\n\t\t\t            _super = superPrototype;\n\t\t\t            return ret;\n\t\t\t\t    };\n\t\t        })( propertyName, addition, superPrototype );\n\t\t\t}else{\n\t\t\t\tpropertyType = 'var';\n\t\t\t\tpropertyDefault = addition;\n\t\t    \tproperty = _.util.deepCopy( addition );\n\t\t    }\n\t\t\tattachTarget[ propertyName ] = property;\n_debug('\\t', propertyKeyword, propertyType, propertyName, '=', propertyDefault );\n\t\t}\n\t\t\n\t\t// Create getter / setter properties\n\t\tfor ( var index in newPrototype.__.getSetterNames ){\n\t\t\tvar getSetterName = newPrototype.__.getSetterNames[ index ];\n//_debug( 'property name:', getSetterName);\t\t\t\n\t\t\tvar getter = newPrototype.__.getters[getSetterName ];\n//_debug( 'getter function:', getter) ;\t\t\n\t\t\tvar setter = newPrototype.__.setters[getSetterName ];\n//_debug( 'setter function:', setter );\t\t\n\t\t\tnewPrototype[ getSetterName ] = ( function( getter, setter, getSetterName ){\n\t\t\t\treturn function ( value ) {\n\t\t\t\t\tif( value === undefined ) {\n\t\t\t\t\t\tif( getter ) {\n//_debug( 'getting', getSetterName, 'of', this, ':', getter());\n\t\t\t\t\t\t\treturn getter.call( this );\n\t\t\t\t\t\t}else return;\n\t\t\t\t\t}\n\t\t\t\t\tif( setter ){\n// _debug( 'setting', getSetterName, 'of', this, 'to', value);\n\t\t\t\t\t\tsetter.call( this, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})( getter, setter, getSetterName );\n\t\t};\n\t\t// The dummy class constructor (scoping)\n\t\tfunction ClassObject() {\n\t\t  // All construction is actually done in the __init__ method (declared using the new Class name as string ( _className ) )\n\t\t\tthis._ = _.util.deepCopy( this._ );\n\t\t\tthis.__ = _.util.deepCopy( this.__ );\n\t\t\tif ( !_.interpreter.initializing ){\n_debug( 'new', this._className );\n\t\t\t\tif ( this._className.indexOf( 'Event' ) < 0 && [ 'Dictionary' ].indexOf( this._className ) < 0 ) {\n\n\t\t\t\t};\n\t\t\t\tfor ( var propertyName in this ){\n\t\t\t\t\tvar property = this[ propertyName ];\n\t\t\t\t\tif ( _.util.isMethod( property ) && [ 'toString', '_get', '_set', '_add' ].indexOf( propertyName) < 0 ){\n//_debug( 'scoping public', propertyName )\n\t\t\t\t\t\tthis[ propertyName ] = _.util.scope( property, this, propertyName );\n\t\t\t\t\t};//if\n\t\t\t\t};//for\n\t\t\t\t\n\t\t\t\tfor ( propertyName in this._ ){\n\t\t\t\t\tvar property = this._[ propertyName ];\n\t\t\t\t\tif ( _.util.isMethod( property ) ){\n//_debug( 'scoping private', propertyName )\n\t\t\t\t\t\tthis._[ propertyName ] = _.util.scope( property, this );\n\t\t\t\t\t}//if\n\t\t\t\t}//for\n\t\t\t  \tif( this.__init__ ) {\n\t\t\t \t\tthis.__init__.apply( this, arguments );\n\t\t\t  \t};//if\n\t\t\t}//if\n\t\t}\n\t\t//inheritance chain\n\t\tnewPrototype._superPrototype =  superPrototype;\n\t\t// Populate our constructed prototype object\n\t\tClassObject.prototype = newPrototype;\n\t\t\n\t\t// Enforce the constructor to be what we expect\n\t\tClassObject.constructor = ClassObject;\n\t\t\n\t\t// And make this class extensible\n\t\tClassObject._plus = arguments.callee;\n\t\t\n\t\treturn ClassObject;\n\t};\n\t\t\t\n\tvar Code = function(){\n\t\treturn Code.c('Code');\n\t};\n\tCode.r = function ( applicationClassPath, parameters ) {\n_debug('Code.r(',applicationClassPath,',', _.util.stringify(parameters), ')');\n\t_.application.parameters = parameters;\n\t_.application.classPath = applicationClassPath;\n\t\tglobal._import = _.loader._import;\n\t\t_import( applicationClassPath );\n\t\t\t\t\n\t};\n\tCode.x = function ( applicationClassPath, parameters ){\n_debug('Code.x(',applicationClassPath,',', _.util.stringify(parameters), ')');\n\t\tparameters = parameters || this._.application.parameters;\n\t\tapplicationClassPath = applicationClassPath || this._.application.classPath;\n\t\tvar applicationClassName = applicationClassPath.split( '.' ).pop();\n\t\tnew global[ applicationClassName ](parameters);//no namespace\n\t\t_.application = {};\n\t};\n\tCode.c = function ( applicationClassPath ) {\n_debug('Code.c(',applicationClassPath,')');\n\t\tvar libPath = 'lib/'+applicationClassPath+'.js';\n\t\tvar buffer;\n\t\tif( fs ) {\n\t\t\ttry{\n\t\t\t\tbuffer = fs.readFileSync( libPath, 'ascii' );\n\t\t\t}catch( e ){\n\t\t\t\t_debug( 'no library at', libPath);\n\t\t\t}\n\t\t}\n\t\tif( ! buffer ){\n\t\t\tvar interpreter = _.interpreter;\n\t\t\t_.interpreter = {\n\t\t\t\tdefineClasses : function () {\n\t_debug( 'bypassing interpreter.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tglobal._import = _.loader._import;\n\t\t\t_import( applicationClassPath );\n\t\t\tbuffer = _.compiler.buffer;\n\t\t\tif( fs && path ){\n\t\t\t\t_debug (' fs & path');\n\t\t\t\tif(! path.existsSync( 'lib/' ) ){\n\t\t\t\t\t_debug( 'creating lib folder')\n\t\t\t\t\tfs.mkdirSync( 'lib/');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t_debug( 'saving lib file to', libPath)\n\t\t\t\tfs.writeFileSync( libPath,  buffer)\n\t\t\t}\n\t\t\t_.compiler.buffer = '';\n\t\t\t_.interpreter = interpreter;\t\n\t\t}\n\t\treturn buffer\n\t};\n\tCode._ = _;\n\tglobal.Code = Code;\t\n\tglobal._import = _.interpreter._import;\n\tglobal._class = _.interpreter._class;\n\t_debug('Code ready.')\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////// Goin' Deep /////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n//\t DEEP COPY props http://oranlooney.com/deep-copy-javascript/\n//\t   This section is part of OWL JavaScript Utilities.\n//\n//\tOWL JavaScript Utilities is free software: you can redistribute it and/or \n//\tmodify it under the terms of the GNU Lesser General Public License\n//\tas published by the Free Software Foundation, either version 3 of\n//\tthe License, or (at your option) any later version.\n//\t\n//\tOWL JavaScript Utilities is distributed in the hope that it will be useful,\n//\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n//\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//\tGNU Lesser General Public License for more details.\n//\t\n//\tTo receive a copy of the GNU Lesser General Public License, see: <http://www.gnu.org/licenses/>.\t\n\n//\t the re-usable constructor function used by clone().\n\tfunction Clone() {};\n\n//\t clone objects, skip other types.\n\tfunction clone(target) {\n\t\tif ( typeof target == 'object' ) {\n\t\t\tClone.prototype = target;\n\t\t\treturn new Clone();\n\t\t} else {\n\t\t\treturn target;\n\t\t}\n\t}\n\n\n//\t Shallow Copy \n\tfunction copy(target) {\n\t\tif (typeof target !== 'object' ) {\n\t\t\treturn target;  // non-object have value sematics, so target is already a copy.\n\t\t} else {\n\t\t\tvar value = target.valueOf();\n\t\t\tif (target != value) { \n//\t\t\t\t the object is a standard object wrapper for a native type, say String.\n//\t\t\t\t we can make a copy by instantiating a new object around the value.\n\t\t\t\treturn new target.constructor(value);\n\t\t\t} else {\n//\t\t\t\t ok, we have a normal object. If possible, we'll clone the original's prototype \n//\t\t\t\t (not the original) to get an empty object with the same prototype chain as\n//\t\t\t\t the original.  If just copy the instance properties.  Otherwise, we have to \n//\t\t\t\t copy the whole thing, property-by-property.\n\t\t\t\tif ( target instanceof target.constructor && target.constructor !== Object ) { \n\t\t\t\t\tvar c = clone(target.constructor.prototype);\n\t\t\t\t\n//\t\t\t\t\t give the copy all the instance properties of target.  It has the same\n//\t\t\t\t\t prototype as target, so inherited properties are already there.\n\t\t\t\t\tfor ( var property in target) { \n\t\t\t\t\t\tif (target.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tc[property] = target[property];\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar c = {};\n\t\t\t\t\tfor ( var property in target ) c[property] = target[property];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t}\n\n//\t Deep Copy\n\tvar deepCopiers = [];\n\n\tfunction DeepCopier(config) {\n\t\tfor ( var key in config ) this[key] = config[key];\n\t}\n\tDeepCopier.prototype = {\n\t\tconstructor: DeepCopier,\n\n//\t\t determines if this DeepCopier can handle the given object.\n\t\tcanCopy: function(source) { return false; },\n\n//\t\t starts the deep copying process by creating the copy object.  You\n//\t\t can initialize any properties you want, but you can't call recursively\n//\t\t into the DeeopCopyAlgorithm.\n\t\tcreate: function(source) { },\n\n//\t\t Completes the deep copy of the source object by populating any properties\n//\t\t that need to be recursively deep copied.  You can do this by using the\n//\t\t provided deepCopyAlgorithm instance's deepCopy() method.  This will handle\n//\t\t cyclic references for objects already deepCopied, including the source object\n//\t\t itself.  The \"result\" passed in is the object returned from create().\n\t\tpopulate: function(deepCopyAlgorithm, source, result) {}\n\t};\n\n\tfunction DeepCopyAlgorithm() {\n//\t\t copiedObjects keeps track of objects already copied by this\n//\t\t deepCopy operation, so we can correctly handle cyclic references.\n\t\tthis.copiedObjects = [];\n\t\tthisPass = this;\n\t\tthis.recursiveDeepCopy = function(source) {\n\t\t\treturn thisPass.deepCopy(source);\n\t\t}\n\t\tthis.depth = 0;\n\t}\n\tDeepCopyAlgorithm.prototype = {\n\t\tconstructor: DeepCopyAlgorithm,\n\n\t\tmaxDepth: 256,\n\t\t\t\n//\t\t add an object to the cache.  No attempt is made to filter duplicates;\n//\t\t we always check getCachedResult() before calling it.\n\t\tcacheResult: function(source, result) {\n\t\t\tthis.copiedObjects.push([source, result]);\n\t\t},\n\n//\t\t Returns the cached copy of a given object, or undefined if it's an\n//\t\t object we haven't seen before.\n\t\tgetCachedResult: function(source) {\n\t\t\tvar copiedObjects = this.copiedObjects;\n\t\t\tvar length = copiedObjects.length;\n\t\t\tfor ( var i=0; i<length; i++ ) {\n\t\t\t\tif ( copiedObjects[i][0] === source ) {\n\t\t\t\t\treturn copiedObjects[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\t\n//\t\t deepCopy handles the simple cases itself: non-objects and object's we've seen before.\n//\t\t For complex cases, it first identifies an appropriate DeepCopier, then calls\n//\t\t applyDeepCopier() to delegate the details of copying the object to that DeepCopier.\n\t\tdeepCopy: function(source) {\n//\t\t\t null is a special case: it's the only value of type 'object' without properties.\n\t\t\tif ( source === null ) return null;\n\n//\t\t\t All non-objects use value semantics and don't need explict copying.\n\t\t\tif ( typeof source !== 'object' ) return source;\n\n\t\t\tvar cachedResult = this.getCachedResult(source);\n\n//\t\t\t we've already seen this object during this deep copy operation\n//\t\t\t so can immediately return the result.  This preserves the cyclic\n//\t\t\t reference structure and protects us from infinite recursion.\n\t\t\tif ( cachedResult ) return cachedResult;\n\n//\t\t\t objects may need special handling depending on their class.  There is\n//\t\t\t a class of handlers call \"DeepCopiers\"  that know how to copy certain\n//\t\t\t objects.  There is also a final, generic deep copier that can handle any object.\n\t\t\tfor ( var i=0; i<deepCopiers.length; i++ ) {\n\t\t\t\tvar deepCopier = deepCopiers[i];\n\t\t\t\tif ( deepCopier.canCopy(source) ) {\n\t\t\t\t\treturn this.applyDeepCopier(deepCopier, source);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// the generic copier can handle anything, so we should never reach this line.\n\t\t\tthrow new Error(\"no DeepCopier is able to copy \" + source);\n\t\t},\n\n//\t\t once we've identified which DeepCopier to use, we need to call it in a very\n//\t\t particular order: create, cache, populate.  This is the key to detecting cycles.\n//\t\t We also keep track of recursion depth when calling the potentially recursive\n//\t\t populate(): this is a fail-fast to prevent an infinite loop from consuming all\n//\t\t available memory and crashing or slowing down the browser.\n\t\tapplyDeepCopier: function(deepCopier, source) {\n//\t\t\t Start by creating a stub object that represents the copy.\n\t\t\tvar result = deepCopier.create(source);\n\n//\t\t\t we now know the deep copy of source should always be result, so if we encounter\n//\t\t\t source again during this deep copy we can immediately use result instead of\n//\t\t\t descending into it recursively.  \n\t\t\tthis.cacheResult(source, result);\n\n//\t\t\t only DeepCopier::populate() can recursively deep copy.  So, to keep track\n//\t\t\t of recursion depth, we increment this shared counter before calling it,\n//\t\t\t and decrement it afterwards.\n\t\t\tthis.depth++;\n\t\t\tif ( this.depth > this.maxDepth ) {\n\t\t\t\tthrow new Error(\"Exceeded max recursion depth in deep copy.\");\n\t\t\t}\n\n//\t\t\t It's now safe to let the deepCopier recursively deep copy its properties.\n\t\t\tdeepCopier.populate(this.recursiveDeepCopy, source, result);\n\n\t\t\tthis.depth--;\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n//\t entry point for deep copy.\n//\t   source is the object to be deep copied.\n//\t   maxDepth is an optional recursion limit. Defaults to 256.\n\tfunction deepCopy(source, maxDepth) {\n\t\tvar deepCopyAlgorithm = new DeepCopyAlgorithm();\n\t\tif ( maxDepth ) deepCopyAlgorithm.maxDepth = maxDepth;\n\t\treturn deepCopyAlgorithm.deepCopy(source);\n\t}\n\n//\t publicly expose the DeepCopier class.\n\tdeepCopy.DeepCopier = DeepCopier;\n\n//\t publicly expose the list of deepCopiers.\n\tdeepCopy.deepCopiers = deepCopiers;\n\n//\t make deepCopy() extensible by allowing others to \n//\t register their own custom DeepCopiers.\n\tdeepCopy.register = function(deepCopier) {\n\t\tif ( !(deepCopier instanceof DeepCopier) ) {\n\t\t\tdeepCopier = new DeepCopier(deepCopier);\n\t\t}\n\t\tdeepCopiers.unshift(deepCopier);\n\t}\n\n//\t Generic Object copier\n//\t the ultimate fallback DeepCopier, which tries to handle the generic case.  This\n//\t should work for base Objects and many user-defined classes.\n\tdeepCopy.register({\n\t\tcanCopy: function(source) { return true; },\n\n\t\tcreate: function(source) {\n\t\t\tif ( source instanceof source.constructor ) {\n\t\t\t\treturn clone(source.constructor.prototype);\n\t\t\t} else {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var key in source ) {\n\t\t\t\tif ( source.hasOwnProperty(key) ) {\n\t\t\t\t\tresult[key] = deepCopy(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t});\n\n//\t Array copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) {\n\t\t\treturn ( source instanceof Array );\n\t\t},\n\n\t\tcreate: function(source) {\n\t\t\treturn new source.constructor();\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var i=0; i<source.length; i++) {\n\t\t\t\tresult.push( deepCopy(source[i]) );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t});\n\n//\t Date copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) {\n\t\t\treturn ( source instanceof Date );\n\t\t},\n\n\t\tcreate: function(source) {\n\t\t\treturn new Date(source);\n\t\t}\n\t});\n\n//\t HTML DOM Node\n\n//\t utility function to detect Nodes.  In particular, we're looking\n//\t for the cloneNode method.  The global document is also defined to\n//\t be a Node, but is a special case in many ways.\n\tfunction isNode(source) {\n\t\tif ( global.Node ) {\n\t\t\treturn source instanceof Node;\n\t\t} else {\n\t\t\t// the document is a special Node and doesn't have many of\n\t\t\t// the common properties so we use an identity check instead.\n\t\t\tif ( typeof document == 'object' && source === document ) return true;\n\t\t\treturn (\n\t\t\t\ttypeof source.nodeType === 'number' &&\n\t\t\t\tsource.attributes &&\n\t\t\t\tsource.childNodes &&\n\t\t\t\tsource.cloneNode\n\t\t\t);\n\t\t}\n\t}\n\n//\t Node copier\n\tdeepCopy.register({\n\t\tcanCopy: function(source) { return isNode(source); },\n\n\t\tcreate: function(source) {\n//\t\t\t there can only be one (document).\n\t\t\tif (typeof document == 'object' && source === document ) return document;\n\n//\t\t\t start with a shallow copy.  We'll handle the deep copy of\n//\t\t\t its children ourselves.\n\t\t\treturn source.cloneNode(false);\n\t\t},\n\n\t\tpopulate: function(deepCopy, source, result) {\n//\t\t\t we're not copying the global document, so don't have to populate it either.\n\t\t\tif ( typeof document == 'object' && source === document ) return document;\n\n//\t\t\t if this Node has children, deep copy them one-by-one.\n\t\t\tif ( source.childNodes && source.childNodes.length ) {\n\t\t\t\tfor ( var i=0; i<source.childNodes.length; i++ ) {\n\t\t\t\t\tvar childCopy = deepCopy(source.childNodes[i]);\n\t\t\t\t\tresult.appendChild(childCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n// Code.js : Fase Dictionary\n\tdeepCopy.register( {\n\t\tcanCopy: function(source) { return source._className == 'Dictionary'; },\n\t\tcreate: function(source) {\n\t\t\treturn new Dictionary();\n\t\t},\n\t\tpopulate: function(deepCopy, source, result) {\n\t\t\tfor ( var i in source._keys ){\n\t\t\t\tresult._keys[ i ] = source._keys[ i ];\n\t\t\t\tresult._values[ i ] = deepCopy( source.values[ i ])\n\t\t\t};\n\t\t}\n\t});\nreturn Code;\n})();"]],"start1":0,"start2":0,"length1":0,"length2":29706}]],"length":29706}
